{"version":3,"sources":["../../src/tools/copyFiles.ts"],"names":["copyFiles","srcPath","destPath","options","Promise","all","map","absoluteSrcFilePath","exclude","some","p","test","relativeFilePath","path","relative","copyFile","resolve","fs","lstatSync","isDirectory","existsSync","mkdirSync","reject","copyBinaryFile","err","cb","cbCalled","mode","statSync","readStream","createReadStream","writeStream","createWriteStream","on","done","chmodSync","pipe"],"mappings":";;;;;;;AAOA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;;;AATA;;;;;;;AAeA;;;AAGA,eAAeA,SAAf,CACEC,OADF,EAEEC,QAFF,EAGEC,OAAgB,GAAG,EAHrB,EAIE;AACA,SAAOC,OAAO,CAACC,GAAR,CACL,mBAAKJ,OAAL,EAAcK,GAAd,CAAkB,MAAOC,mBAAP,IAAuC;AACvD,UAAMC,OAAO,GAAGL,OAAO,CAACK,OAAxB;;AACA,QAAIA,OAAO,IAAIA,OAAO,CAACC,IAAR,CAAcC,CAAD,IAAOA,CAAC,CAACC,IAAF,CAAOJ,mBAAP,CAApB,CAAf,EAAiE;AAC/D;AACD;;AACD,UAAMK,gBAAgB,GAAGC,gBAAKC,QAAL,CAAcb,OAAd,EAAuBM,mBAAvB,CAAzB;;AACA,UAAMQ,QAAQ,CACZR,mBADY,EAEZM,gBAAKG,OAAL,CAAad,QAAb,EAAuBU,gBAAvB,CAFY,CAAd;AAID,GAVD,CADK,CAAP;AAaD;AAED;;;;;AAGA,SAASG,QAAT,CAAkBd,OAAlB,EAAmCC,QAAnC,EAAqD;AACnD,MAAIe,cAAGC,SAAH,CAAajB,OAAb,EAAsBkB,WAAtB,EAAJ,EAAyC;AACvC,QAAI,CAACF,cAAGG,UAAH,CAAclB,QAAd,CAAL,EAA8B;AAC5Be,oBAAGI,SAAH,CAAanB,QAAb;AACD,KAHsC,CAIvC;;;AACA;AACD;;AAED,SAAO,IAAIE,OAAJ,CAAY,CAACY,OAAD,EAAUM,MAAV,KAAqB;AACtCC,IAAAA,cAAc,CAACtB,OAAD,EAAUC,QAAV,EAAqBsB,GAAD,IAAS;AACzC,UAAIA,GAAJ,EAAS;AACPF,QAAAA,MAAM,CAACE,GAAD,CAAN;AACD;;AACDR,MAAAA,OAAO,CAACd,QAAD,CAAP;AACD,KALa,CAAd;AAMD,GAPM,CAAP;AAQD;AAED;;;;;AAGA,SAASqB,cAAT,CACEtB,OADF,EAEEC,QAFF,EAGEuB,EAHF,EAIE;AACA,MAAIC,QAAQ,GAAG,KAAf;;AACA,QAAM;AAACC,IAAAA;AAAD,MAASV,cAAGW,QAAH,CAAY3B,OAAZ,CAAf;;AACA,QAAM4B,UAAU,GAAGZ,cAAGa,gBAAH,CAAoB7B,OAApB,CAAnB;;AACA,QAAM8B,WAAW,GAAGd,cAAGe,iBAAH,CAAqB9B,QAArB,CAApB;;AACA2B,EAAAA,UAAU,CAACI,EAAX,CAAc,OAAd,EAAwBT,GAAD,IAAS;AAC9BU,IAAAA,IAAI,CAACV,GAAD,CAAJ;AACD,GAFD;AAGAO,EAAAA,WAAW,CAACE,EAAZ,CAAe,OAAf,EAAyBT,GAAD,IAAS;AAC/BU,IAAAA,IAAI,CAACV,GAAD,CAAJ;AACD,GAFD;AAGAK,EAAAA,UAAU,CAACI,EAAX,CAAc,OAAd,EAAuB,MAAM;AAC3BC,IAAAA,IAAI;;AACJjB,kBAAGkB,SAAH,CAAajC,QAAb,EAAuByB,IAAvB;AACD,GAHD;AAIAE,EAAAA,UAAU,CAACO,IAAX,CAAgBL,WAAhB;;AACA,WAASG,IAAT,CAAcV,GAAd,EAA2B;AACzB,QAAI,CAACE,QAAL,EAAe;AACbD,MAAAA,EAAE,CAACD,GAAD,CAAF;AACAE,MAAAA,QAAQ,GAAG,IAAX;AACD;AACF;AACF;;eAEc1B,S","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport walk from './walk';\n\ntype Options = {\n  exclude?: Array<RegExp>;\n};\n\n/**\n * Copy files (binary included) recursively.\n */\nasync function copyFiles(\n  srcPath: string,\n  destPath: string,\n  options: Options = {},\n) {\n  return Promise.all(\n    walk(srcPath).map(async (absoluteSrcFilePath: string) => {\n      const exclude = options.exclude;\n      if (exclude && exclude.some((p) => p.test(absoluteSrcFilePath))) {\n        return;\n      }\n      const relativeFilePath = path.relative(srcPath, absoluteSrcFilePath);\n      await copyFile(\n        absoluteSrcFilePath,\n        path.resolve(destPath, relativeFilePath),\n      );\n    }),\n  );\n}\n\n/**\n * Copy a file to given destination.\n */\nfunction copyFile(srcPath: string, destPath: string) {\n  if (fs.lstatSync(srcPath).isDirectory()) {\n    if (!fs.existsSync(destPath)) {\n      fs.mkdirSync(destPath);\n    }\n    // Not recursive\n    return;\n  }\n\n  return new Promise((resolve, reject) => {\n    copyBinaryFile(srcPath, destPath, (err) => {\n      if (err) {\n        reject(err);\n      }\n      resolve(destPath);\n    });\n  });\n}\n\n/**\n * Same as 'cp' on Unix. Don't do any replacements.\n */\nfunction copyBinaryFile(\n  srcPath: string,\n  destPath: string,\n  cb: (err?: Error) => void,\n) {\n  let cbCalled = false;\n  const {mode} = fs.statSync(srcPath);\n  const readStream = fs.createReadStream(srcPath);\n  const writeStream = fs.createWriteStream(destPath);\n  readStream.on('error', (err) => {\n    done(err);\n  });\n  writeStream.on('error', (err) => {\n    done(err);\n  });\n  readStream.on('close', () => {\n    done();\n    fs.chmodSync(destPath, mode);\n  });\n  readStream.pipe(writeStream);\n  function done(err?: Error) {\n    if (!cbCalled) {\n      cb(err);\n      cbCalled = true;\n    }\n  }\n}\n\nexport default copyFiles;\n"]}