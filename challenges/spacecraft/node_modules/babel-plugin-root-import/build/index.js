'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _helper = require('./helper');

var _callExpressionTester = require('./call-expression-tester');

var _callExpressionTester2 = _interopRequireDefault(_callExpressionTester);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var replacePrefix = function replacePrefix(path) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var sourceFile = arguments[2];

  var paths = 'paths' in opts ? opts.paths : opts;
  var options = [].concat(paths);

  for (var i = 0; i < options.length; i++) {
    var rootPathSuffix = '';
    var rootPathPrefix = '';
    var option = options[i];

    if (option.rootPathSuffix && typeof option.rootPathSuffix === 'string') {
      rootPathSuffix = option.rootPathSuffix;
    }
    if (option.rootPathPrefix && typeof option.rootPathPrefix === 'string') {
      rootPathPrefix = option.rootPathPrefix;
    } else {
      rootPathPrefix = '~';
    }

    if ((0, _helper.hasRootPathPrefixInString)(path, rootPathPrefix)) {
      return (0, _helper.transformRelativeToRootPath)(path, rootPathSuffix, rootPathPrefix, sourceFile, option.root || undefined);
    }
  }

  return path;
};

var replacePrefixStrOrQuasi = function replacePrefixStrOrQuasi(node, opts, sourceFile) {
  // String literal
  if (typeof node === 'string') {
    return replacePrefix(node, opts, sourceFile);
  }
  // Template literal quasi
  else if (node && typeof node.cooked === 'string') {
      return _extends({}, node, {
        cooked: replacePrefix(node.cooked, opts, sourceFile),
        raw: replacePrefix(node.raw, opts, sourceFile)
      });
    } else {
      return node;
    }
};

/**
 * Recursively traverses binary  expressions to find the first `StringLiteral` if any.
 * @param  {Object} t           Babel types
 * @param  {Node} arg           a Babel node
 * @return {StringLiteral?}
 */
var traverseExpression = function traverseExpression(t, arg) {
  if (t.isTemplateLiteral(arg)) {
    return arg.quasis[0];
  }

  if (t.isStringLiteral(arg)) {
    return arg;
  }

  if (t.isBinaryExpression(arg)) {
    return traverseExpression(t, arg.left);
  }

  return null;
};

exports.default = function (_ref) {
  var t = _ref.types;

  var callExpressionTester = void 0;
  var visitor = {
    CallExpression: function CallExpression(path, state) {
      if (!callExpressionTester.test(path)) {
        return;
      }

      var args = path.node.arguments;
      if (!args.length) {
        return;
      }

      var firstArg = traverseExpression(t, args[0]);

      if (firstArg) {
        firstArg.value = replacePrefixStrOrQuasi(firstArg.value, state.opts, state.file.opts.filename);
      }
    },
    ImportDeclaration: function ImportDeclaration(path, state) {
      path.node.source.value = replacePrefix(path.node.source.value, state.opts, state.file.opts.filename);
    },
    ExportNamedDeclaration: function ExportNamedDeclaration(path, state) {
      if (path.node.source) {
        path.node.source.value = replacePrefix(path.node.source.value, state.opts, state.file.opts.filename);
      }
    },
    ExportAllDeclaration: function ExportAllDeclaration(path, state) {
      if (path.node.source) {
        path.node.source.value = replacePrefix(path.node.source.value, state.opts, state.file.opts.filename);
      }
    }
  };
  return {
    visitor: {
      Program: function Program(path, state) {
        callExpressionTester = new _callExpressionTester2.default(t, state.opts);
        path.traverse(visitor, state);
      }
    }
  };
};