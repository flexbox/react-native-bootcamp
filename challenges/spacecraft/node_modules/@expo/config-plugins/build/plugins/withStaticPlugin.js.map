{"version":3,"sources":["../../src/plugins/withStaticPlugin.ts"],"names":["EXPO_DEBUG","EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS","EXPO_USE_UNVERSIONED_PLUGINS","isModuleMissingError","name","error","includes","code","message","isUnexpectedTokenError","SyntaxError","PluginError","match","withStaticPlugin","config","props","projectRoot","_internal","pluginResolve","pluginProps","plugin","_resolverError","withPlugin","_isLegacyPlugin","fallback","console","log","shouldMuteWarning"],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport { boolish } from 'getenv';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\nimport {\n  assertInternalProjectRoot,\n  normalizeStaticPlugin,\n  resolveConfigPluginFunction,\n} from '../utils/plugin-resolver';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\n// Show all error info related to plugin resolution.\nconst EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = boolish('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\n// Force using the fallback unversioned plugin instead of a local versioned copy,\n// this should only be used for testing the CLI.\nconst EXPO_USE_UNVERSIONED_PLUGINS = boolish('EXPO_USE_UNVERSIONED_PLUGINS', false);\n\nfunction isModuleMissingError(name: string, error: Error): boolean {\n  // @ts-ignore\n  if (['MODULE_NOT_FOUND', 'PLUGIN_NOT_FOUND'].includes(error.code)) {\n    return true;\n  }\n  return error.message.includes(`Cannot find module '${name}'`);\n}\n\nfunction isUnexpectedTokenError(error: Error): boolean {\n  if (\n    error instanceof SyntaxError ||\n    (error instanceof PluginError && error.code === 'INVALID_PLUGIN_IMPORT')\n  ) {\n    return (\n      // These are the most common errors that'll be thrown when a package isn't transpiled correctly.\n      !!error.message.match(/Unexpected token/) ||\n      !!error.message.match(/Cannot use import statement/)\n    );\n  }\n  return false;\n}\n\n/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n * @param _isLegacyPlugin Used to suppress errors thrown by plugins that are applied automatically\n */\nexport const withStaticPlugin: ConfigPlugin<{\n  plugin: StaticPlugin | ConfigPlugin | string;\n  fallback?: ConfigPlugin<{ _resolverError: Error } & any>;\n  projectRoot?: string;\n  _isLegacyPlugin?: boolean;\n}> = (config, props) => {\n  let projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    projectRoot = config._internal?.projectRoot;\n    assertInternalProjectRoot(projectRoot);\n  }\n\n  let [pluginResolve, pluginProps] = normalizeStaticPlugin(props.plugin);\n  // Ensure no one uses this property by accident.\n  assert(\n    !pluginProps?._resolverError,\n    `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``\n  );\n\n  let withPlugin: ConfigPlugin<unknown>;\n\n  if (\n    // Function was provided, no need to resolve: [withPlugin, {}]\n    typeof pluginResolve === 'function'\n  ) {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      // Resolve and evaluate plugins.\n      withPlugin = resolveConfigPluginFunction(projectRoot, pluginResolve);\n\n      // Only force if the project has the versioned plugin, otherwise use default behavior.\n      // This helps see which plugins are being skipped.\n      if (\n        EXPO_USE_UNVERSIONED_PLUGINS &&\n        !!withPlugin &&\n        !!props._isLegacyPlugin &&\n        !!props.fallback\n      ) {\n        console.log(`Force \"${pluginResolve}\" to unversioned plugin`);\n        withPlugin = props.fallback;\n      }\n    } catch (error: any) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n          console.log(`Error resolving plugin \"${pluginResolve}\"`);\n          console.log(error);\n          console.log();\n        } else {\n          const shouldMuteWarning =\n            props._isLegacyPlugin &&\n            (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              // Prevent causing log spew for basic resolution errors.\n              console.log(`Could not find plugin \"${pluginResolve}\"`);\n            } else {\n              // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n              console.log(`Error resolving plugin \"${pluginResolve}\"`);\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n      // TODO: Maybe allow for `PluginError`s to be thrown so external plugins can assert invalid options.\n\n      // If the static module failed to resolve, attempt to use a fallback.\n      // This enables support for built-in plugins with versioned variations living in other packages.\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        // Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        // If no fallback, throw the resolution error.\n        throw error;\n      }\n    }\n  } else {\n    throw new PluginError(\n      `Plugin is an unexpected type: ${typeof pluginResolve}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  // Execute the plugin.\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n"],"file":"withStaticPlugin.js"}