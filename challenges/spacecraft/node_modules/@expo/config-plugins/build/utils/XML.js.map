{"version":3,"sources":["../../src/utils/XML.ts"],"names":["writeXMLAsync","options","xml","format","fs","promises","mkdir","path","dirname","recursive","writeFile","readXMLAsync","contents","readFile","encoding","flag","parser","Parser","manifest","parseStringPromise","fallback","Array","isArray","resources","string","$","translatable","_","unescapeAndroidString","parseXMLAsync","stringTimesN","n","char","join","indentLevel","newline","EOL","xmlInput","toString","builder","Builder","headless","escapeAndroidString","buildObject","Error","indentString","formatted","regex","replace","pad","split","map","line","trim","forEach","indent","match","padding","value","m"],"mappings":";;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAUO,eAAeA,aAAf,CAA6BC,OAA7B,EAAiF;AACtF,QAAMC,GAAG,GAAGC,MAAM,CAACF,OAAO,CAACC,GAAT,CAAlB;AACA,QAAME,cAAGC,QAAH,CAAYC,KAAZ,CAAkBC,gBAAKC,OAAL,CAAaP,OAAO,CAACM,IAArB,CAAlB,EAA8C;AAAEE,IAAAA,SAAS,EAAE;AAAb,GAA9C,CAAN;AACA,QAAML,cAAGC,QAAH,CAAYK,SAAZ,CAAsBT,OAAO,CAACM,IAA9B,EAAoCL,GAApC,CAAN;AACD;;AAEM,eAAeS,YAAf,CAA4BV,OAA5B,EAGgB;AAAA;;AACrB,MAAIW,QAAgB,GAAG,EAAvB;;AACA,MAAI;AACFA,IAAAA,QAAQ,GAAG,MAAMR,cAAGC,QAAH,CAAYQ,QAAZ,CAAqBZ,OAAO,CAACM,IAA7B,EAAmC;AAAEO,MAAAA,QAAQ,EAAE,MAAZ;AAAoBC,MAAAA,IAAI,EAAE;AAA1B,KAAnC,CAAjB;AACD,GAFD,CAEE,MAAM,CACN;AACD;;AACD,QAAMC,MAAM,GAAG,KAAIC,gBAAJ,GAAf;AACA,QAAMC,QAAQ,GAAG,MAAMF,MAAM,CAACG,kBAAP,CAA0BP,QAAQ,IAAIX,OAAO,CAACmB,QAApB,IAAgC,EAA1D,CAAvB,CARqB,CAUrB;;AACA,MAAIC,KAAK,CAACC,OAAN,CAAcJ,QAAd,aAAcA,QAAd,8CAAcA,QAAQ,CAAEK,SAAxB,wDAAc,oBAAqBC,MAAnC,CAAJ,EAAgD;AAC9C,SAAK,MAAMA,MAAX,IAAqBN,QAArB,aAAqBA,QAArB,+CAAqBA,QAAQ,CAAEK,SAA/B,yDAAqB,qBAAqBC,MAA1C,EAAkD;AAAA;;AAChD,UAAIA,MAAM,CAACC,CAAP,CAASC,YAAT,KAA0B,OAA1B,IAAqCF,MAAM,CAACC,CAAP,CAASC,YAAT,KAA0B,KAAnE,EAA0E;AACxE;AACD;;AACDF,MAAAA,MAAM,CAACG,CAAP,GAAWC,qBAAqB,CAACJ,MAAM,CAACG,CAAR,CAAhC;AACD;AACF;;AAED,SAAOT,QAAP;AACD;;AAEM,eAAeW,aAAf,CAA6BjB,QAA7B,EAAmE;AACxE,QAAMV,GAAG,GAAG,MAAM,KAAIe,gBAAJ,IAAaE,kBAAb,CAAgCP,QAAhC,CAAlB;AACA,SAAOV,GAAP;AACD;;AAED,MAAM4B,YAAY,GAAG,CAACC,CAAD,EAAYC,IAAZ,KAA6BX,KAAK,CAACU,CAAC,GAAG,CAAL,CAAL,CAAaE,IAAb,CAAkBD,IAAlB,CAAlD;;AAEO,SAAS7B,MAAT,CAAgBe,QAAhB,EAA+B;AAAEgB,EAAAA,WAAW,GAAG,CAAhB;AAAmBC,EAAAA,OAAO,GAAGC;AAA7B,IAAqC,EAApE,EAAgF;AACrF,MAAIC,QAAJ;;AACA,MAAI,OAAOnB,QAAP,KAAoB,QAAxB,EAAkC;AAChCmB,IAAAA,QAAQ,GAAGnB,QAAX;AACD,GAFD,MAEO,IAAIA,QAAQ,CAACoB,QAAb,EAAuB;AAAA;;AAC5B,UAAMC,OAAO,GAAG,KAAIC,iBAAJ,EAAY;AAC1BC,MAAAA,QAAQ,EAAE;AADgB,KAAZ,CAAhB,CAD4B,CAK5B;;AACA,QAAIpB,KAAK,CAACC,OAAN,CAAcJ,QAAd,aAAcA,QAAd,+CAAcA,QAAQ,CAAEK,SAAxB,yDAAc,qBAAqBC,MAAnC,CAAJ,EAAgD;AAC9C,WAAK,MAAMA,MAAX,IAAqBN,QAArB,aAAqBA,QAArB,+CAAqBA,QAAQ,CAAEK,SAA/B,yDAAqB,qBAAqBC,MAA1C,EAAkD;AAAA;;AAChD,YAAIA,MAAM,CAACC,CAAP,CAASC,YAAT,KAA0B,OAA1B,IAAqCF,MAAM,CAACC,CAAP,CAASC,YAAT,KAA0B,KAAnE,EAA0E;AACxE;AACD;;AACDF,QAAAA,MAAM,CAACG,CAAP,GAAWe,mBAAmB,CAAClB,MAAM,CAACG,CAAR,CAA9B;AACD;AACF;;AAEDU,IAAAA,QAAQ,GAAGE,OAAO,CAACI,WAAR,CAAoBzB,QAApB,CAAX;AAEA,WAAOmB,QAAP;AACD,GAlBM,MAkBA;AACL,UAAM,IAAIO,KAAJ,CAAW,gCAA+B1B,QAAS,EAAnD,CAAN;AACD;;AACD,QAAM2B,YAAY,GAAGf,YAAY,CAACI,WAAD,EAAc,GAAd,CAAjC;AAEA,MAAIY,SAAS,GAAG,EAAhB;AACA,QAAMC,KAAK,GAAG,cAAd;AACA,QAAM7C,GAAG,GAAGmC,QAAQ,CAACW,OAAT,CAAiBD,KAAjB,EAAyB,KAAIZ,OAAQ,MAArC,CAAZ;AACA,MAAIc,GAAG,GAAG,CAAV;AACA/C,EAAAA,GAAG,CACAgD,KADH,CACS,OADT,EAEGC,GAFH,CAEQC,IAAD,IAAkBA,IAAI,CAACC,IAAL,EAFzB,EAGGC,OAHH,CAGYF,IAAD,IAAkB;AACzB,QAAIG,MAAM,GAAG,CAAb;;AACA,QAAIH,IAAI,CAACI,KAAL,CAAW,gBAAX,CAAJ,EAAkC;AAChCD,MAAAA,MAAM,GAAG,CAAT;AACD,KAFD,MAEO,IAAIH,IAAI,CAACI,KAAL,CAAW,QAAX,CAAJ,EAA0B;AAC/B,UAAIP,GAAG,KAAK,CAAZ,EAAe;AACbA,QAAAA,GAAG,IAAI,CAAP;AACD;AACF,KAJM,MAIA,IAAIG,IAAI,CAACI,KAAL,CAAW,sBAAX,CAAJ,EAAwC;AAC7CD,MAAAA,MAAM,GAAG,CAAT;AACD,KAFM,MAEA;AACLA,MAAAA,MAAM,GAAG,CAAT;AACD;;AAED,UAAME,OAAO,GAAG3B,YAAY,CAACmB,GAAD,EAAMJ,YAAN,CAA5B;AACAC,IAAAA,SAAS,IAAIW,OAAO,GAAGL,IAAV,GAAiBjB,OAA9B;AACAc,IAAAA,GAAG,IAAIM,MAAP;AACD,GApBH;AAsBA,SAAOT,SAAS,CAACO,IAAV,EAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,SAASX,mBAAT,CAA6BgB,KAA7B,EAAoD;AACzDA,EAAAA,KAAK,GAAGA,KAAK,CAACV,OAAN,CAAc,cAAd,EAA8BW,CAAC,IAAI;AACzC,YAAQA,CAAR;AACE,WAAK,GAAL;AACA,WAAK,GAAL;AACA,WAAK,GAAL;AACE,eAAO,OAAOA,CAAd;;AACF,WAAK,IAAL;AACE,eAAO,KAAP;;AACF,WAAK,IAAL;AACE,eAAO,KAAP;;AACF,WAAK,IAAL;AACE,eAAO,KAAP;;AACF;AACE,cAAM,IAAIf,KAAJ,CAAW,0CAAyCe,CAAE,EAAtD,CAAN;AAZJ;AAcD,GAfO,CAAR;;AAgBA,MAAID,KAAK,CAACF,KAAN,CAAY,WAAZ,CAAJ,EAA8B;AAC5BE,IAAAA,KAAK,GAAG,MAAMA,KAAN,GAAc,GAAtB;AACD;;AACD,SAAOA,KAAP;AACD;;AAEM,SAAS9B,qBAAT,CAA+B8B,KAA/B,EAAsD;AAC3D,SAAOA,KAAK,CAACV,OAAN,CAAc,QAAd,EAAwB,IAAxB,CAAP;AACD","sourcesContent":["import fs from 'fs';\nimport { EOL } from 'os';\nimport path from 'path';\nimport { Builder, Parser } from 'xml2js';\n\nexport type XMLValue = boolean | number | string | null | XMLArray | XMLObject;\n\nexport interface XMLArray extends Array<XMLValue> {}\n\nexport interface XMLObject {\n  [key: string]: XMLValue | undefined;\n}\n\nexport async function writeXMLAsync(options: { path: string; xml: any }): Promise<void> {\n  const xml = format(options.xml);\n  await fs.promises.mkdir(path.dirname(options.path), { recursive: true });\n  await fs.promises.writeFile(options.path, xml);\n}\n\nexport async function readXMLAsync(options: {\n  path: string;\n  fallback?: string | null;\n}): Promise<XMLObject> {\n  let contents: string = '';\n  try {\n    contents = await fs.promises.readFile(options.path, { encoding: 'utf8', flag: 'r' });\n  } catch {\n    // catch and use fallback\n  }\n  const parser = new Parser();\n  const manifest = await parser.parseStringPromise(contents || options.fallback || '');\n\n  // For strings.xml\n  if (Array.isArray(manifest?.resources?.string)) {\n    for (const string of manifest?.resources?.string) {\n      if (string.$.translatable === 'false' || string.$.translatable === false) {\n        continue;\n      }\n      string._ = unescapeAndroidString(string._);\n    }\n  }\n\n  return manifest;\n}\n\nexport async function parseXMLAsync(contents: string): Promise<XMLObject> {\n  const xml = await new Parser().parseStringPromise(contents);\n  return xml;\n}\n\nconst stringTimesN = (n: number, char: string) => Array(n + 1).join(char);\n\nexport function format(manifest: any, { indentLevel = 2, newline = EOL } = {}): string {\n  let xmlInput: string;\n  if (typeof manifest === 'string') {\n    xmlInput = manifest;\n  } else if (manifest.toString) {\n    const builder = new Builder({\n      headless: true,\n    });\n\n    // For strings.xml\n    if (Array.isArray(manifest?.resources?.string)) {\n      for (const string of manifest?.resources?.string) {\n        if (string.$.translatable === 'false' || string.$.translatable === false) {\n          continue;\n        }\n        string._ = escapeAndroidString(string._);\n      }\n    }\n\n    xmlInput = builder.buildObject(manifest);\n\n    return xmlInput;\n  } else {\n    throw new Error(`Invalid XML value passed in: ${manifest}`);\n  }\n  const indentString = stringTimesN(indentLevel, ' ');\n\n  let formatted = '';\n  const regex = /(>)(<)(\\/*)/g;\n  const xml = xmlInput.replace(regex, `$1${newline}$2$3`);\n  let pad = 0;\n  xml\n    .split(/\\r?\\n/)\n    .map((line: string) => line.trim())\n    .forEach((line: string) => {\n      let indent = 0;\n      if (line.match(/.+<\\/\\w[^>]*>$/)) {\n        indent = 0;\n      } else if (line.match(/^<\\/\\w/)) {\n        if (pad !== 0) {\n          pad -= 1;\n        }\n      } else if (line.match(/^<\\w([^>]*[^/])?>.*$/)) {\n        indent = 1;\n      } else {\n        indent = 0;\n      }\n\n      const padding = stringTimesN(pad, indentString);\n      formatted += padding + line + newline;\n      pad += indent;\n    });\n\n  return formatted.trim();\n}\n\n/**\n * Escapes Android string literals, specifically characters `\"`, `'`, `\\`, `\\n`, `\\r`, `\\t`\n *\n * @param value unescaped Android XML string literal.\n */\nexport function escapeAndroidString(value: string): string {\n  value = value.replace(/[\\n\\r\\t'\"@]/g, m => {\n    switch (m) {\n      case '\"':\n      case \"'\":\n      case '@':\n        return '\\\\' + m;\n      case '\\n':\n        return '\\\\n';\n      case '\\r':\n        return '\\\\r';\n      case '\\t':\n        return '\\\\t';\n      default:\n        throw new Error(`Cannot escape unhandled XML character: ${m}`);\n    }\n  });\n  if (value.match(/(^\\s|\\s$)/)) {\n    value = '\"' + value + '\"';\n  }\n  return value;\n}\n\nexport function unescapeAndroidString(value: string): string {\n  return value.replace(/\\\\(.)/g, '$1');\n}\n"],"file":"XML.js"}