{"version":3,"file":"index.js","sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport type { Scope, NodePath } from \"@babel/traverse\";\nimport type { TraversalAncestors } from \"@babel/types\";\n\n/**\n * Test if an ArrayPattern's elements contain any RestElements.\n */\n\nfunction hasArrayRest(pattern: t.ArrayPattern) {\n  return pattern.elements.some(elem => t.isRestElement(elem));\n}\n\n/**\n * Test if an ObjectPattern's properties contain any RestElements.\n */\n\nfunction hasObjectRest(pattern: t.ObjectPattern) {\n  return pattern.properties.some(prop => t.isRestElement(prop));\n}\n\ninterface UnpackableArrayExpression extends t.ArrayExpression {\n  elements: (null | t.Expression)[];\n}\n\nconst STOP_TRAVERSAL = {};\n\ninterface ArrayUnpackVisitorState {\n  deopt: boolean;\n  bindings: Record<string, t.Identifier>;\n}\n\n// NOTE: This visitor is meant to be used via t.traverse\nconst arrayUnpackVisitor = (\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: ArrayUnpackVisitorState,\n) => {\n  if (!ancestors.length) {\n    // Top-level node: this is the array literal.\n    return;\n  }\n\n  if (\n    t.isIdentifier(node) &&\n    t.isReferenced(node, ancestors[ancestors.length - 1].node) &&\n    state.bindings[node.name]\n  ) {\n    state.deopt = true;\n    throw STOP_TRAVERSAL;\n  }\n};\n\ntype DestructuringTransformerNode =\n  | t.VariableDeclaration\n  | t.ExpressionStatement\n  | t.ReturnStatement;\n\ninterface DestructuringTransformerOption {\n  blockHoist?: number;\n  operator?: t.AssignmentExpression[\"operator\"];\n  nodes?: DestructuringTransformerNode[];\n  kind?: t.VariableDeclaration[\"kind\"];\n  scope: Scope;\n  arrayLikeIsIterable: boolean;\n  iterableIsArray: boolean;\n  objectRestNoSymbols: boolean;\n  useBuiltIns: boolean;\n  addHelper: File[\"addHelper\"];\n}\nexport class DestructuringTransformer {\n  private blockHoist: number;\n  private operator: t.AssignmentExpression[\"operator\"];\n  arrayRefSet: Set<string>;\n  private nodes: DestructuringTransformerNode[];\n  private scope: Scope;\n  private kind: t.VariableDeclaration[\"kind\"];\n  private iterableIsArray: boolean;\n  private arrayLikeIsIterable: boolean;\n  private objectRestNoSymbols: boolean;\n  private useBuiltIns: boolean;\n  private addHelper: File[\"addHelper\"];\n  constructor(opts: DestructuringTransformerOption) {\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n\n  getExtendsHelper() {\n    return this.useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : this.addHelper(\"extends\");\n  }\n\n  buildVariableAssignment(\n    id:\n      | t.Identifier\n      | t.MemberExpression\n      | t.RestElement\n      | t.TSParameterProperty,\n    init: t.Expression,\n  ) {\n    let op = this.operator;\n    if (t.isMemberExpression(id)) op = \"=\";\n\n    let node: t.ExpressionStatement | t.VariableDeclaration;\n\n    if (op) {\n      node = t.expressionStatement(\n        t.assignmentExpression(\n          op,\n          id,\n          t.cloneNode(init) || this.scope.buildUndefinedNode(),\n        ),\n      );\n    } else {\n      let nodeInit: t.Expression;\n\n      if (this.kind === \"const\" && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = t.cloneNode(init);\n      }\n\n      node = t.variableDeclaration(this.kind, [\n        t.variableDeclarator(id, nodeInit),\n      ]);\n    }\n\n    //@ts-expect-error(todo): document block hoist property\n    node._blockHoist = this.blockHoist;\n\n    return node;\n  }\n\n  buildVariableDeclaration(id: t.Identifier, init: t.Expression) {\n    const declar = t.variableDeclaration(\"var\", [\n      t.variableDeclarator(t.cloneNode(id), t.cloneNode(init)),\n    ]);\n    // @ts-expect-error todo(flow->ts): avoid mutations\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n\n  push(id: t.LVal, _init: t.Expression | null) {\n    const init = t.cloneNode(_init);\n    if (t.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (t.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (t.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  }\n\n  toArray(node: t.Expression, count?: boolean | number) {\n    if (\n      this.iterableIsArray ||\n      (t.isIdentifier(node) && this.arrayRefSet.has(node.name))\n    ) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count, this.arrayLikeIsIterable);\n    }\n  }\n\n  pushAssignmentPattern(\n    { left, right }: t.AssignmentPattern,\n    valueRef: t.Expression | null,\n  ) {\n    // handle array init hole\n    // const [x = 42] = [,];\n    // -> const x = 42;\n    if (valueRef === null) {\n      this.push(left, right);\n      return;\n    }\n\n    // we need to assign the current value of the assignment to avoid evaluating\n    // it more than once\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n\n    const tempConditional = t.conditionalExpression(\n      t.binaryExpression(\n        \"===\",\n        t.cloneNode(tempId),\n        this.scope.buildUndefinedNode(),\n      ),\n      right,\n      t.cloneNode(tempId),\n    );\n\n    if (t.isPattern(left)) {\n      let patternId;\n      let node;\n\n      if (this.kind === \"const\" || this.kind === \"let\") {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n\n        node = t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(tempId), tempConditional),\n        );\n      }\n\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n\n  pushObjectRest(\n    pattern: t.ObjectPattern,\n    objRef: t.Expression,\n    spreadProp: t.RestElement,\n    spreadPropIndex: number,\n  ) {\n    const value = buildObjectExcludingKeys(\n      pattern.properties.slice(0, spreadPropIndex) as t.ObjectProperty[],\n      objRef,\n      this.scope,\n      name => this.addHelper(name),\n      this.objectRestNoSymbols,\n      this.useBuiltIns,\n    );\n    // @ts-expect-error: The argument of a RestElement in ObjectPattern must not be an ArrayPattern\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n\n  pushObjectProperty(prop: t.ObjectProperty, propRef: t.Expression) {\n    if (t.isLiteral(prop.key)) prop.computed = true;\n\n    const pattern = prop.value as t.LVal;\n    const objRef = t.memberExpression(\n      t.cloneNode(propRef),\n      prop.key,\n      prop.computed,\n    );\n\n    if (t.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n\n  pushObjectPattern(pattern: t.ObjectPattern, objRef: t.Expression | null) {\n    // https://github.com/babel/babel/issues/681\n\n    if (!pattern.properties.length || objRef === null) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(\n            this.addHelper(\"objectDestructuringEmpty\"),\n            objRef !== null ? [objRef] : [],\n          ),\n        ),\n      );\n      return;\n    }\n\n    // if we have more than one properties in this pattern and the objectRef is a\n    // member expression then we need to assign it to a temporary variable so it's\n    // only evaluated once\n\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n\n    // Replace impure computed key expressions if we have a rest parameter\n    if (hasObjectRest(pattern)) {\n      let copiedPattern;\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (t.isRestElement(prop)) {\n          break;\n        }\n        const key = prop.key;\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(this.buildVariableDeclaration(name, key));\n          if (!copiedPattern) {\n            copiedPattern = pattern = {\n              ...pattern,\n              properties: pattern.properties.slice(),\n            };\n          }\n          copiedPattern.properties[i] = {\n            ...copiedPattern.properties[i],\n            key: name,\n          };\n        }\n      }\n    }\n    //\n\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n      if (t.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n\n  canUnpackArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: t.Expression,\n  ): arr is UnpackableArrayExpression {\n    // not an array so there's no way we can deal with this\n    if (!t.isArrayExpression(arr)) return false;\n\n    // pattern has less elements than the array and doesn't have a rest so some\n    // elements wont be evaluated\n    if (pattern.elements.length > arr.elements.length) return;\n    if (\n      pattern.elements.length < arr.elements.length &&\n      !hasArrayRest(pattern)\n    ) {\n      return false;\n    }\n\n    for (const elem of pattern.elements) {\n      // deopt on holes\n      if (!elem) return false;\n\n      // deopt on member expressions as they may be included in the RHS\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    for (const elem of arr.elements) {\n      // deopt on spread elements\n      if (t.isSpreadElement(elem)) return false;\n\n      // deopt call expressions as they might change values of LHS variables\n      if (t.isCallExpression(elem)) return false;\n\n      // deopt on member expressions as they may be getter/setters and have side-effects\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    // deopt on reference to left side identifiers\n    const bindings = t.getBindingIdentifiers(pattern);\n    const state: ArrayUnpackVisitorState = { deopt: false, bindings };\n\n    try {\n      t.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n\n    return !state.deopt;\n  }\n\n  pushUnpackedArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: UnpackableArrayExpression,\n  ) {\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (t.isRestElement(elem)) {\n        this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));\n      } else {\n        this.push(elem, arr.elements[i]);\n      }\n    }\n  }\n\n  pushArrayPattern(pattern: t.ArrayPattern, arrayRef: t.Expression | null) {\n    if (arrayRef === null) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(this.addHelper(\"objectDestructuringEmpty\"), []),\n        ),\n      );\n      return;\n    }\n    if (!pattern.elements) return;\n\n    // optimise basic array destructuring of an array expression\n    //\n    // we can't do this to a pattern of unequal size to it's right hand\n    // array expression as then there will be values that wont be evaluated\n    //\n    // eg: let [a, b] = [1, 2];\n\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      return this.pushUnpackedArrayPattern(pattern, arrayRef);\n    }\n\n    // if we have a rest then we need all the elements so don't tell\n    // `scope.toArray` to only get a certain amount\n\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n\n    // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will\n    // return a locally bound identifier if it's been inferred to be an array,\n    // otherwise it'll be a call to a helper that will ensure it's one\n\n    const toArray = this.toArray(arrayRef, count);\n\n    if (t.isIdentifier(toArray)) {\n      // we've been given an identifier so it must have been inferred to be an\n      // array\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n\n    //\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n\n      // hole\n      if (!elem) continue;\n\n      let elemRef;\n\n      if (t.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = t.callExpression(\n          t.memberExpression(elemRef, t.identifier(\"slice\")),\n          [t.numericLiteral(i)],\n        );\n\n        // set the element to the rest element argument since we've dealt with it\n        // being a rest already\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n\n  init(pattern: t.LVal, ref: t.Expression) {\n    // trying to destructure a value that we can't evaluate more than once so we\n    // need to save it to a variable\n\n    if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, t.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n\n    //\n\n    this.push(pattern, ref);\n\n    return this.nodes;\n  }\n}\n\ninterface ExcludingKey {\n  key: t.Expression | t.PrivateName;\n  computed: boolean;\n}\n\nexport function buildObjectExcludingKeys<T extends ExcludingKey>(\n  excludedKeys: T[],\n  objRef: t.Expression,\n  scope: Scope,\n  addHelper: File[\"addHelper\"],\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n): t.CallExpression {\n  // get all the keys that appear in this object before the current spread\n\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n    if (t.isIdentifier(key) && !prop.computed) {\n      keys.push(t.stringLiteral(key.name));\n    } else if (t.isTemplateLiteral(key)) {\n      keys.push(t.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (t.isLiteral(key)) {\n      // @ts-expect-error todo(flow->ts) NullLiteral\n      keys.push(t.stringLiteral(String(key.value)));\n    } else if (t.isPrivateName(key)) {\n      // private key is not enumerable\n    } else {\n      keys.push(t.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n\n  let value;\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : addHelper(\"extends\");\n    value = t.callExpression(extendsHelper, [\n      t.objectExpression([]),\n      t.cloneNode(objRef),\n    ]);\n  } else {\n    let keyExpression: t.Expression = t.arrayExpression(keys);\n\n    if (!allLiteral) {\n      keyExpression = t.callExpression(\n        t.memberExpression(keyExpression, t.identifier(\"map\")),\n        [addHelper(\"toPropertyKey\")],\n      );\n    } else if (!hasTemplateLiteral && !t.isProgram(scope.block)) {\n      // Hoist definition of excluded keys, so that it's not created each time.\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\",\n      });\n\n      keyExpression = t.cloneNode(id);\n    }\n\n    value = t.callExpression(\n      addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`),\n      [t.cloneNode(objRef), keyExpression],\n    );\n  }\n  return value;\n}\n\nexport function convertVariableDeclaration(\n  path: NodePath<t.VariableDeclaration>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope } = path;\n\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n\n    const patternId = declar.init;\n    const pattern = declar.id;\n\n    const destructuring = new DestructuringTransformer({\n      // @ts-expect-error(todo): avoid internal properties access\n      blockHoist: node._blockHoist,\n      nodes: nodes,\n      scope: scope,\n      kind: node.kind,\n      iterableIsArray,\n      arrayLikeIsIterable,\n      useBuiltIns,\n      objectRestNoSymbols,\n      addHelper,\n    });\n\n    if (t.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n\n      if (+i !== node.declarations.length - 1) {\n        // we aren't the last declarator so let's just make the\n        // last transformed node inherit from us\n        t.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(\n        t.inherits(\n          destructuring.buildVariableAssignment(pattern, patternId),\n          declar,\n        ),\n      );\n    }\n  }\n\n  let tail: t.VariableDeclaration | null = null;\n  const nodesOut = [];\n  for (const node of nodes) {\n    if (tail !== null && t.isVariableDeclaration(node)) {\n      // Create a single compound declarations\n      tail.declarations.push(...node.declarations);\n    } else {\n      // Make sure the original node kind is used for each compound declaration\n      node.kind = nodeKind;\n      // Propagate the original declaration node's location\n      if (!node.loc) {\n        node.loc = nodeLoc;\n      }\n      nodesOut.push(node);\n      tail = t.isVariableDeclaration(node) ? node : null;\n    }\n  }\n\n  // Need to unmark the current binding to this var as a param, or other hoists\n  // could be placed above this ref.\n  // https://github.com/babel/babel/issues/4516\n  for (const nodeOut of nodesOut) {\n    if (!nodeOut.declarations) continue;\n    for (const declaration of nodeOut.declarations) {\n      const { name } = declaration.id;\n      if (scope.bindings[name]) {\n        scope.bindings[name].kind = nodeOut.kind;\n      }\n    }\n  }\n\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n}\n\nexport function convertAssignmentExpression(\n  path: NodePath<t.AssignmentExpression>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope } = path;\n\n  const nodes = [];\n\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper,\n  });\n\n  let ref: t.Identifier | void;\n  if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n\n    nodes.push(\n      t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.right)]),\n    );\n\n    if (t.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n\n  destructuring.init(node.left, ref || node.right);\n\n  if (ref) {\n    if (path.parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(t.blockStatement([]));\n      nodes.push(t.returnStatement(t.cloneNode(ref)));\n    } else {\n      nodes.push(t.expressionStatement(t.cloneNode(ref)));\n    }\n  }\n\n  path.replaceWithMultiple(nodes);\n  path.scope.crawl();\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport {\n  DestructuringTransformer,\n  convertVariableDeclaration,\n  convertAssignmentExpression,\n} from \"./util\";\nimport type { PluginPass } from \"@babel/core\";\nimport type { Visitor } from \"@babel/traverse\";\n\n/**\n * Test if a VariableDeclaration's declarations contains any Patterns.\n */\n\nfunction variableDeclarationHasPattern(node: t.VariableDeclaration) {\n  for (const declar of node.declarations) {\n    if (t.isPattern(declar.id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport default declare((api, options) => {\n  api.assertVersion(7);\n\n  const { useBuiltIns = false } = options;\n\n  const iterableIsArray = api.assumption(\"iterableIsArray\") ?? options.loose;\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\");\n  const objectRestNoSymbols =\n    api.assumption(\"objectRestNoSymbols\") ?? options.loose;\n\n  return {\n    name: \"transform-destructuring\",\n\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(\n            t.exportSpecifier(t.identifier(name), t.identifier(name)),\n          );\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n      },\n\n      ForXStatement(path) {\n        const { node, scope } = path;\n        const left = node.left;\n\n        if (t.isPattern(left)) {\n          // for ({ length: k } in { abc: 3 });\n\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n          const statementBody = (node.body as t.BlockStatement).body;\n\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            statementBody.unshift(\n              t.expressionStatement(scope.buildUndefinedNode()),\n            );\n          }\n\n          statementBody.unshift(\n            t.expressionStatement(t.assignmentExpression(\"=\", left, temp)),\n          );\n\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) return;\n\n        const pattern = left.declarations[0].id;\n        if (!t.isPattern(pattern)) return;\n\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = t.variableDeclaration(left.kind, [\n          t.variableDeclarator(key, null),\n        ]);\n\n        const nodes = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n\n        destructuring.init(pattern, key);\n\n        path.ensureBlock();\n\n        const block = node.body;\n        // @ts-expect-error: ensureBlock ensures that node.body is a BlockStatement\n        block.body = nodes.concat(block.body);\n      },\n\n      CatchClause({ node, scope }) {\n        const pattern = node.param;\n        if (!t.isPattern(pattern)) return;\n\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n\n        const nodes = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n        destructuring.init(pattern, ref);\n\n        node.body.body = nodes.concat(node.body.body);\n      },\n\n      AssignmentExpression(path, state) {\n        if (!t.isPattern(path.node.left)) return;\n        convertAssignmentExpression(\n          path,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n\n      VariableDeclaration(path, state) {\n        const { node, parent } = path;\n        if (t.isForXStatement(parent)) return;\n        if (!parent || !path.container) return; // i don't know why this is necessary - TODO\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(\n          path,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n    } as Visitor<PluginPass>,\n  };\n});\n"],"names":["hasArrayRest","pattern","elements","some","elem","t","isRestElement","hasObjectRest","properties","prop","STOP_TRAVERSAL","arrayUnpackVisitor","node","ancestors","state","length","isIdentifier","isReferenced","bindings","name","deopt","DestructuringTransformer","constructor","opts","blockHoist","operator","arrayRefSet","nodes","scope","kind","iterableIsArray","arrayLikeIsIterable","objectRestNoSymbols","useBuiltIns","addHelper","Set","getExtendsHelper","memberExpression","identifier","buildVariableAssignment","id","init","op","isMemberExpression","expressionStatement","assignmentExpression","cloneNode","buildUndefinedNode","nodeInit","variableDeclaration","variableDeclarator","_blockHoist","buildVariableDeclaration","declar","push","_init","isObjectPattern","pushObjectPattern","isArrayPattern","pushArrayPattern","isAssignmentPattern","pushAssignmentPattern","toArray","count","has","left","right","valueRef","tempId","generateUidIdentifierBasedOnNode","tempConditional","conditionalExpression","binaryExpression","isPattern","patternId","generateUidIdentifier","pushObjectRest","objRef","spreadProp","spreadPropIndex","value","buildObjectExcludingKeys","slice","argument","pushObjectProperty","propRef","isLiteral","key","computed","callExpression","isStatic","temp","copiedPattern","i","isPure","canUnpackArrayPattern","arr","isArrayExpression","isSpreadElement","isCallExpression","getBindingIdentifiers","traverse","e","pushUnpackedArrayPattern","arrayExpression","arrayRef","add","elemRef","numericLiteral","ref","memo","maybeGenerateMemoised","excludedKeys","keys","allLiteral","hasTemplateLiteral","stringLiteral","isTemplateLiteral","String","isPrivateName","extendsHelper","objectExpression","keyExpression","isProgram","block","programScope","getProgramParent","convertVariableDeclaration","path","nodeKind","nodeLoc","loc","declarations","destructuring","inherits","tail","nodesOut","isVariableDeclaration","nodeOut","declaration","replaceWith","replaceWithMultiple","convertAssignmentExpression","isCompletionRecord","parentPath","isExpressionStatement","isArrowFunctionExpression","blockStatement","returnStatement","crawl","variableDeclarationHasPattern","declare","api","options","assertVersion","assumption","loose","allowArrayLike","visitor","ExportNamedDeclaration","get","specifiers","Object","getOuterBindingIdentifiers","exportSpecifier","insertAfter","exportNamedDeclaration","ForXStatement","ensureBlock","statementBody","body","unshift","concat","CatchClause","param","AssignmentExpression","VariableDeclaration","parent","isForXStatement","container"],"mappings":"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"}