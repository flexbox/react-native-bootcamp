{"version":3,"sources":["../../src/tools/copyAndReplace.ts"],"names":["binaryExtensions","copyAndReplace","srcPath","destPath","replacements","contentChangedCallback","fs","lstatSync","isDirectory","existsSync","mkdirSync","extension","path","extname","indexOf","shouldOverwrite","newContentBuffer","readFileSync","contentChanged","origContentBuffer","Buffer","compare","err","code","copyBinaryFile","srcPermissions","statSync","mode","content","Object","keys","forEach","regex","replace","RegExp","origContent","writeFileSync","encoding","cb","cbCalled","readStream","createReadStream","on","done","writeStream","createWriteStream","pipe"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\n// Binary files, don't process these (avoid decoding as utf8)\nconst binaryExtensions = ['.png', '.jar', '.keystore'];\n\ntype ContentChangedCallbackOption = 'identical' | 'changed' | 'new' | null;\n\n/**\n * Copy a file to given destination, replacing parts of its contents.\n * @param srcPath Path to a file to be copied.\n * @param destPath Destination path.\n * @param replacements: e.g. {'TextToBeReplaced': 'Replacement'}\n * @param contentChangedCallback\n *        Used when upgrading projects. Based on if file contents would change\n *        when being replaced, allows the caller to specify whether the file\n *        should be replaced or not.\n *        If null, files will be overwritten.\n *        Function(path, 'identical' | 'changed' | 'new') => 'keep' | 'overwrite'\n */\nfunction copyAndReplace(\n  srcPath: string,\n  destPath: string,\n  replacements: Record<string, string>,\n  contentChangedCallback:\n    | ((\n        path: string,\n        option: ContentChangedCallbackOption,\n      ) => 'keep' | 'overwrite')\n    | null,\n) {\n  if (fs.lstatSync(srcPath).isDirectory()) {\n    if (!fs.existsSync(destPath)) {\n      fs.mkdirSync(destPath);\n    }\n    // Not recursive\n    return;\n  }\n\n  const extension = path.extname(srcPath);\n  if (binaryExtensions.indexOf(extension) !== -1) {\n    // Binary file\n    let shouldOverwrite = 'overwrite';\n    if (contentChangedCallback) {\n      const newContentBuffer = fs.readFileSync(srcPath);\n      let contentChanged: ContentChangedCallbackOption = 'identical';\n      try {\n        const origContentBuffer = fs.readFileSync(destPath);\n        if (Buffer.compare(origContentBuffer, newContentBuffer) !== 0) {\n          contentChanged = 'changed';\n        }\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          contentChanged = 'new';\n        } else {\n          throw err;\n        }\n      }\n      shouldOverwrite = contentChangedCallback(destPath, contentChanged);\n    }\n    if (shouldOverwrite === 'overwrite') {\n      copyBinaryFile(srcPath, destPath, (err) => {\n        if (err) {\n          throw err;\n        }\n      });\n    }\n  } else {\n    // Text file\n    const srcPermissions = fs.statSync(srcPath).mode;\n    let content = fs.readFileSync(srcPath, 'utf8');\n    Object.keys(replacements).forEach((regex) => {\n      content = content.replace(new RegExp(regex, 'g'), replacements[regex]);\n    });\n\n    let shouldOverwrite = 'overwrite';\n    if (contentChangedCallback) {\n      // Check if contents changed and ask to overwrite\n      let contentChanged: ContentChangedCallbackOption = 'identical';\n      try {\n        const origContent = fs.readFileSync(destPath, 'utf8');\n        if (content !== origContent) {\n          // logger.info('Content changed: ' + destPath);\n          contentChanged = 'changed';\n        }\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          contentChanged = 'new';\n        } else {\n          throw err;\n        }\n      }\n      shouldOverwrite = contentChangedCallback(destPath, contentChanged);\n    }\n    if (shouldOverwrite === 'overwrite') {\n      fs.writeFileSync(destPath, content, {\n        encoding: 'utf8',\n        mode: srcPermissions,\n      });\n    }\n  }\n}\n\n/**\n * Same as 'cp' on Unix. Don't do any replacements.\n */\nfunction copyBinaryFile(\n  srcPath: string,\n  destPath: string,\n  cb: (err?: Error) => void,\n) {\n  let cbCalled = false;\n  const srcPermissions = fs.statSync(srcPath).mode;\n  const readStream = fs.createReadStream(srcPath);\n  readStream.on('error', (err) => {\n    done(err);\n  });\n  const writeStream = fs.createWriteStream(destPath, {\n    mode: srcPermissions,\n  });\n  writeStream.on('error', (err) => {\n    done(err);\n  });\n  writeStream.on('close', () => {\n    done();\n  });\n  readStream.pipe(writeStream);\n  function done(err?: Error) {\n    if (!cbCalled) {\n      cb(err);\n      cbCalled = true;\n    }\n  }\n}\n\nexport default copyAndReplace;\n"]}