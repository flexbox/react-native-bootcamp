{"version":3,"sources":["../../src/utils/matchBrackets.ts"],"names":["LEFT_BRACKETS","RIGHT_BRACKETS","findMatchingBracketPosition","contents","bracket","offset","firstBracketPos","indexOf","stackCounter","matchingBracket","getMatchingBracket","isLeftBracket","contentsLength","length","i","c","leftBracketList","includes","Error"],"mappings":";;;;;;AAAA,MAAMA,aAAa,GAAG,CAAC,GAAD,EAAM,GAAN,CAAtB;AACA,MAAMC,cAAc,GAAG,CAAC,GAAD,EAAM,GAAN,CAAvB;;AAMO,SAASC,2BAAT,CACLC,QADK,EAELC,OAFK,EAGLC,MAAc,GAAG,CAHZ,EAIG;AACR;AACA,QAAMC,eAAe,GAAGH,QAAQ,CAACI,OAAT,CAAiBH,OAAjB,EAA0BC,MAA1B,CAAxB;;AACA,MAAIC,eAAe,GAAG,CAAtB,EAAyB;AACvB,WAAO,CAAC,CAAR;AACD;;AAED,MAAIE,YAAY,GAAG,CAAnB;AACA,QAAMC,eAAe,GAAGC,kBAAkB,CAACN,OAAD,CAA1C;;AAEA,MAAIO,aAAa,CAACP,OAAD,CAAjB,EAA4B;AAC1B,UAAMQ,cAAc,GAAGT,QAAQ,CAACU,MAAhC,CAD0B,CAE1B;;AACA,SAAK,IAAIC,CAAC,GAAGR,eAAe,GAAG,CAA/B,EAAkCQ,CAAC,GAAGF,cAAtC,EAAsD,EAAEE,CAAxD,EAA2D;AACzD,YAAMC,CAAC,GAAGZ,QAAQ,CAACW,CAAD,CAAlB;;AACA,UAAIC,CAAC,KAAKX,OAAV,EAAmB;AACjBI,QAAAA,YAAY,IAAI,CAAhB;AACD,OAFD,MAEO,IAAIO,CAAC,KAAKN,eAAV,EAA2B;AAChC,YAAID,YAAY,KAAK,CAArB,EAAwB;AACtB,iBAAOM,CAAP;AACD;;AACDN,QAAAA,YAAY,IAAI,CAAhB;AACD;AACF;AACF,GAdD,MAcO;AACL;AACA,SAAK,IAAIM,CAAC,GAAGR,eAAe,GAAG,CAA/B,EAAkCQ,CAAC,IAAI,CAAvC,EAA0C,EAAEA,CAA5C,EAA+C;AAC7C,YAAMC,CAAC,GAAGZ,QAAQ,CAACW,CAAD,CAAlB;;AACA,UAAIC,CAAC,KAAKX,OAAV,EAAmB;AACjBI,QAAAA,YAAY,IAAI,CAAhB;AACD,OAFD,MAEO,IAAIO,CAAC,KAAKN,eAAV,EAA2B;AAChC,YAAID,YAAY,KAAK,CAArB,EAAwB;AACtB,iBAAOM,CAAP;AACD;;AACDN,QAAAA,YAAY,IAAI,CAAhB;AACD;AACF;AACF;;AAED,SAAO,CAAC,CAAR;AACD;;AAED,SAASG,aAAT,CAAuBP,OAAvB,EAAkD;AAChD,QAAMY,eAAmC,GAAGhB,aAA5C;AACA,SAAOgB,eAAe,CAACC,QAAhB,CAAyBb,OAAzB,CAAP;AACD;;AAED,SAASM,kBAAT,CAA4BN,OAA5B,EAAuD;AACrD,UAAQA,OAAR;AACE,SAAK,GAAL;AACE,aAAO,GAAP;;AACF,SAAK,GAAL;AACE,aAAO,GAAP;;AACF,SAAK,GAAL;AACE,aAAO,GAAP;;AACF,SAAK,GAAL;AACE,aAAO,GAAP;;AACF;AACE,YAAM,IAAIc,KAAJ,CAAW,yBAAwBd,OAAQ,EAA3C,CAAN;AAVJ;AAYD","sourcesContent":["const LEFT_BRACKETS = ['(', '{'] as const;\nconst RIGHT_BRACKETS = [')', '}'] as const;\n\ntype LeftBracket = typeof LEFT_BRACKETS[number];\ntype RightBracket = typeof RIGHT_BRACKETS[number];\ntype Bracket = LeftBracket | RightBracket;\n\nexport function findMatchingBracketPosition(\n  contents: string,\n  bracket: Bracket,\n  offset: number = 0\n): number {\n  // search first occurrence of `bracket`\n  const firstBracketPos = contents.indexOf(bracket, offset);\n  if (firstBracketPos < 0) {\n    return -1;\n  }\n\n  let stackCounter = 0;\n  const matchingBracket = getMatchingBracket(bracket);\n\n  if (isLeftBracket(bracket)) {\n    const contentsLength = contents.length;\n    // search forward\n    for (let i = firstBracketPos + 1; i < contentsLength; ++i) {\n      const c = contents[i];\n      if (c === bracket) {\n        stackCounter += 1;\n      } else if (c === matchingBracket) {\n        if (stackCounter === 0) {\n          return i;\n        }\n        stackCounter -= 1;\n      }\n    }\n  } else {\n    // search backward\n    for (let i = firstBracketPos - 1; i >= 0; --i) {\n      const c = contents[i];\n      if (c === bracket) {\n        stackCounter += 1;\n      } else if (c === matchingBracket) {\n        if (stackCounter === 0) {\n          return i;\n        }\n        stackCounter -= 1;\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction isLeftBracket(bracket: Bracket): boolean {\n  const leftBracketList: readonly Bracket[] = LEFT_BRACKETS;\n  return leftBracketList.includes(bracket);\n}\n\nfunction getMatchingBracket(bracket: Bracket): Bracket {\n  switch (bracket) {\n    case '(':\n      return ')';\n    case ')':\n      return '(';\n    case '{':\n      return '}';\n    case '}':\n      return '{';\n    default:\n      throw new Error(`Unsupported bracket - ${bracket}`);\n  }\n}\n"],"file":"matchBrackets.js"}