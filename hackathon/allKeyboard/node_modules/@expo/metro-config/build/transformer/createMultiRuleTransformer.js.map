{"version":3,"file":"createMultiRuleTransformer.js","sourceRoot":"","sources":["../../src/transformer/createMultiRuleTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2021-present 650 Industries (Expo). All rights reserved.\n\nimport chalk from 'chalk';\nimport Debug from 'debug';\nimport type { BabelTransformer, BabelTransformerArgs } from 'metro-babel-transformer';\nimport resolveFrom from 'resolve-from';\n\nimport { generateFunctionMap } from './generateFunctionMap';\nimport { getBabelConfig } from './getBabelConfig';\n\nconst debug = Debug('expo:metro:exotic-babel-transformer');\n\nlet babelCore: typeof import('@babel/core') | undefined;\n\nfunction getBabelCoreFromProject(projectRoot: string) {\n  if (babelCore) return babelCore;\n  babelCore = require(resolveFrom(projectRoot, '@babel/core'));\n  return babelCore!;\n}\n\nlet babelParser: typeof import('@babel/parser') | undefined;\n\nfunction getBabelParserFromProject(projectRoot: string) {\n  if (babelParser) return babelParser;\n  babelParser = require(resolveFrom(projectRoot, '@babel/parser'));\n  return babelParser!;\n}\n\nfunction sucrase(\n  args: BabelTransformerArgs,\n  {\n    transforms,\n  }: {\n    transforms: string[];\n  }\n): Partial<ReturnType<BabelTransformer['transform']>> {\n  const {\n    src,\n    filename,\n    options: { dev },\n  } = args;\n  const { transform } = require('sucrase');\n\n  const results = transform(src, {\n    filePath: filename,\n    production: !dev,\n    transforms,\n  });\n\n  return {\n    code: results.code,\n    functionMap: null,\n  };\n}\n\nconst getExpensiveSucraseTransforms = (filename: string) => [\n  'jsx',\n  'imports',\n  /\\.tsx?$/.test(filename) ? 'typescript' : 'flow',\n];\n\nfunction parseAst(projectRoot: string, sourceCode: string) {\n  const babylon = getBabelParserFromProject(projectRoot);\n\n  return babylon.parse(sourceCode, {\n    sourceType: 'unambiguous',\n  });\n}\n\nexport type Rule = {\n  warn?: boolean;\n  type?: 'module' | 'app';\n  name?: string;\n  test: ((args: BabelTransformerArgs) => boolean) | RegExp;\n  transform: BabelTransformer['transform'];\n};\n\n/** Create a transformer that emulates Webpack's loader system. */\nexport function createMultiRuleTransformer({\n  getRuleType,\n  rules,\n}: {\n  getRuleType: (args: BabelTransformerArgs) => string;\n  rules: Rule[];\n}): BabelTransformer['transform'] {\n  // const warnings: string[] = [];\n  return function transform(args: BabelTransformerArgs) {\n    const { filename, options } = args;\n    const OLD_BABEL_ENV = process.env.BABEL_ENV;\n    process.env.BABEL_ENV = options?.dev ? 'development' : process.env.BABEL_ENV || 'production';\n\n    try {\n      const ruleType = getRuleType(args);\n\n      for (const rule of rules) {\n        // optimization for checking node modules\n        if (rule.type && rule.type !== ruleType) {\n          continue;\n        }\n\n        const isMatched =\n          typeof rule.test === 'function' ? rule.test(args) : rule.test.test(args.filename);\n        if (isMatched) {\n          const results = rule.transform(args);\n          // @ts-ignore: Add extra property for testing\n          results._ruleName = rule.name;\n          // Perform a basic parse if none exists, this enables us to control the output, but only if it changed.\n          if (results.code && !results.ast) {\n            // Parse AST with babel otherwise Metro transformer will throw away the returned results.\n            results.ast = parseAst(options?.projectRoot, results.code);\n          }\n\n          // TODO: Suboptimal warnings\n          // if (rule.warn) {\n          //   const matchName =\n          //     filename.match(/node_modules\\/((:?@[\\w\\d-]+\\/[\\w\\d-]+)|(:?[\\w\\d-]+))\\/?/)?.[1] ??\n          //     filename;\n          //   if (matchName && !warnings.includes(matchName)) {\n          //     warnings.push(matchName);\n          //     console.warn(chalk.yellow.bold`warn `, matchName);\n          //     console.warn(\n          //       chalk.yellow`untranspiled module is potentially causing bundler slowdown, using modules that support commonjs will make your dev server much faster.`\n          //     );\n          //   }\n          // }\n\n          return results;\n        }\n      }\n      throw new Error('no loader rule to handle file: ' + filename);\n    } finally {\n      if (OLD_BABEL_ENV) {\n        process.env.BABEL_ENV = OLD_BABEL_ENV;\n      }\n    }\n  };\n}\n\nexport const loaders: Record<string, (args: BabelTransformerArgs) => any> = {\n  // Perform the standard, and most expensive transpilation sequence.\n  app(args) {\n    debug('app:', args.filename);\n\n    const { filename, options, src, plugins } = args;\n    const babelConfig = {\n      // ES modules require sourceType='module' but OSS may not always want that\n      sourceType: 'unambiguous',\n      ...getBabelConfig(filename, options, plugins),\n      // Variables that are exposed to the user's babel preset.\n      caller: {\n        name: 'metro',\n\n        platform: options.platform,\n      },\n      ast: true,\n    };\n\n    // Surface a warning function so babel linters can be used.\n    Object.defineProperty(babelConfig.caller, 'onWarning', {\n      enumerable: false,\n      writable: false,\n      value: (babelConfig.caller.onWarning = function (msg: any) {\n        // Format the file path first so users know where the warning came from.\n        console.warn(chalk.bold.yellow`warn ` + args.filename);\n        console.warn(msg);\n      }),\n    });\n\n    const { parseSync, transformFromAstSync } = getBabelCoreFromProject(options.projectRoot);\n    const sourceAst = parseSync(src, babelConfig);\n\n    // Should never happen.\n    if (!sourceAst) return { ast: null };\n\n    const result = transformFromAstSync(sourceAst, src, babelConfig);\n\n    // TODO: Disable by default\n    const functionMap = generateFunctionMap(options.projectRoot, sourceAst, { filename });\n    // The result from `transformFromAstSync` can be null (if the file is ignored)\n    if (!result) {\n      return { ast: null, functionMap };\n    }\n\n    return { ast: result.ast, functionMap };\n  },\n\n  // Transpile react-native with sucrase.\n  reactNativeModule(args) {\n    debug('rn:', args.filename);\n    return sucrase(args, {\n      transforms: ['jsx', 'flow', 'imports'],\n    });\n  },\n\n  // Transpile expo modules with sucrase.\n  expoModule(args) {\n    debug('expo:', args.filename);\n    // TODO: Fix all expo packages\n    return sucrase(args, {\n      transforms: [\n        'imports',\n        // TODO: fix expo-processing, expo/vector-icons\n        /(expo-processing|expo\\/vector-icons)/.test(args.filename) && 'jsx',\n        // TODO: fix expo-asset-utils\n        /(expo-asset-utils)/.test(args.filename) && 'flow',\n      ].filter(Boolean) as string[],\n    });\n  },\n\n  // Transpile known community modules with the most expensive sucrase\n  untranspiledModule(args) {\n    debug('known issues:', args.filename);\n    return sucrase(args, {\n      transforms: getExpensiveSucraseTransforms(args.filename),\n    });\n  },\n\n  // Pass all modules through without transpiling them.\n  passthroughModule(args) {\n    const { filename, options, src } = args;\n    debug('passthrough:', filename);\n\n    // Perform a basic ast parse, this doesn't matter since the worker will parse and ignore anyways.\n    const ast = parseAst(options.projectRoot, src);\n\n    // TODO: Disable by default\n    const functionMap = generateFunctionMap(options.projectRoot, ast, { filename });\n\n    return {\n      code: src,\n      functionMap,\n      ast,\n    };\n  },\n};\n"]}