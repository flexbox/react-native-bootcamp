/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 * @format
 */

'use strict';

import type {SchemaType} from '../../../CodegenSchema';
import type {MethodSerializationOutput} from './serializeMethod';

const {createAliasResolver, getModules} = require('../Utils');

const {StructCollector} = require('./StructCollector');
const {serializeStruct} = require('./header/serializeStruct');
const {serializeMethod} = require('./serializeMethod');
const {serializeModuleSource} = require('./source/serializeModule');

type FilesOutput = Map<string, string>;

const ModuleDeclarationTemplate = ({
  hasteModuleName,
  structDeclarations,
  protocolMethods,
}: $ReadOnly<{
  hasteModuleName: string,
  structDeclarations: string,
  protocolMethods: string,
}>) => `${structDeclarations}
@protocol ${hasteModuleName}Spec <RCTBridgeModule, RCTTurboModule>

${protocolMethods}

@end
namespace facebook {
  namespace react {
    /**
     * ObjC++ class for module '${hasteModuleName}'
     */
    class JSI_EXPORT ${hasteModuleName}SpecJSI : public ObjCTurboModule {
    public:
      ${hasteModuleName}SpecJSI(const ObjCTurboModule::InitParams &params);
    };
  } // namespace react
} // namespace facebook`;

const HeaderFileTemplate = ({
  moduleDeclarations,
  structInlineMethods,
}: $ReadOnly<{
  moduleDeclarations: string,
  structInlineMethods: string,
}>) => `/**
 * ${'C'}opyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * ${'@'}generated by codegen project: GenerateModuleObjCpp
 *
 * We create an umbrella header (and corresponding implementation) here since
 * Cxx compilation in BUCK has a limitation: source-code producing genrule()s
 * must have a single output. More files => more genrule()s => slower builds.
 */

#ifndef __cplusplus
#error This file must be compiled as Obj-C++. If you are importing it, you must change your file extension to .mm.
#endif
#import <Foundation/Foundation.h>
#import <RCTRequired/RCTRequired.h>
#import <RCTTypeSafety/RCTConvertHelpers.h>
#import <RCTTypeSafety/RCTTypedModuleConstants.h>
#import <React/RCTBridgeModule.h>
#import <React/RCTCxxConvert.h>
#import <React/RCTManagedPointer.h>
#import <ReactCommon/RCTTurboModule.h>
#import <folly/Optional.h>
#import <vector>

${moduleDeclarations}
${structInlineMethods}
`;

const SourceFileTemplate = ({
  headerFileName,
  moduleImplementations,
}: $ReadOnly<{
  headerFileName: string,
  moduleImplementations: string,
}>) => `/**
 * ${'C'}opyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * ${'@'}generated by codegen project: GenerateModuleObjCpp
 *
 * We create an umbrella header (and corresponding implementation) here since
 * Cxx compilation in BUCK has a limitation: source-code producing genrule()s
 * must have a single output. More files => more genrule()s => slower builds.
 */

#import "${headerFileName}"

${moduleImplementations}
`;

module.exports = {
  generate(
    libraryName: string,
    schema: SchemaType,
    moduleSpecName: string,
    packageName?: string,
  ): FilesOutput {
    const nativeModules = getModules(schema);

    const moduleDeclarations: Array<string> = [];
    const structInlineMethods: Array<string> = [];
    const moduleImplementations: Array<string> = [];

    const hasteModuleNames: Array<string> = Object.keys(nativeModules).sort();
    for (const hasteModuleName of hasteModuleNames) {
      const {
        aliases,
        excludedPlatforms,
        spec: {properties},
      } = nativeModules[hasteModuleName];
      if (excludedPlatforms != null && excludedPlatforms.includes('iOS')) {
        continue;
      }
      const resolveAlias = createAliasResolver(aliases);
      const structCollector = new StructCollector();

      const methodSerializations: Array<MethodSerializationOutput> = [];
      const serializeProperty = property => {
        methodSerializations.push(
          ...serializeMethod(
            hasteModuleName,
            property,
            structCollector,
            resolveAlias,
          ),
        );
      };

      /**
       * Note: As we serialize NativeModule methods, we insert structs into
       * StructCollector, as we encounter them.
       */
      properties
        .filter(property => property.name !== 'getConstants')
        .forEach(serializeProperty);
      properties
        .filter(property => property.name === 'getConstants')
        .forEach(serializeProperty);

      const generatedStructs = structCollector.getAllStructs();
      const structStrs = [];
      const methodStrs = [];

      for (const struct of generatedStructs) {
        const {methods, declaration} = serializeStruct(hasteModuleName, struct);
        structStrs.push(declaration);
        methodStrs.push(methods);
      }

      moduleDeclarations.push(
        ModuleDeclarationTemplate({
          hasteModuleName: hasteModuleName,
          structDeclarations: structStrs.join('\n'),
          protocolMethods: methodSerializations
            .map(({protocolMethod}) => protocolMethod)
            .join('\n'),
        }),
      );

      structInlineMethods.push(methodStrs.join('\n'));

      moduleImplementations.push(
        serializeModuleSource(
          hasteModuleName,
          generatedStructs,
          methodSerializations.filter(
            ({selector}) => selector !== '@selector(constantsToExport)',
          ),
        ),
      );
    }

    const headerFileName = `${moduleSpecName}.h`;
    const headerFile = HeaderFileTemplate({
      moduleDeclarations: moduleDeclarations.join('\n'),
      structInlineMethods: structInlineMethods.join('\n'),
    });

    const sourceFileName = `${moduleSpecName}-generated.mm`;
    const sourceFile = SourceFileTemplate({
      headerFileName,
      moduleImplementations: moduleImplementations.join('\n'),
    });

    return new Map([
      [headerFileName, headerFile],
      [sourceFileName, sourceFile],
    ]);
  },
};
