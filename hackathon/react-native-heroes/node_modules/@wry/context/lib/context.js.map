{"version":3,"file":"context.js","sources":["context.esm.js"],"sourcesContent":["// This currentContext variable will only be used if the makeSlotClass\r\n// function is called, which happens only if this is the first copy of the\r\n// @wry/context package to be imported.\r\nvar currentContext = null;\r\n// This unique internal object is used to denote the absence of a value\r\n// for a given Slot, and is never exposed to outside code.\r\nvar MISSING_VALUE = {};\r\nvar idCounter = 1;\r\n// Although we can't do anything about the cost of duplicated code from\r\n// accidentally bundling multiple copies of the @wry/context package, we can\r\n// avoid creating the Slot class more than once using makeSlotClass.\r\nvar makeSlotClass = function () { return /** @class */ (function () {\r\n    function Slot() {\r\n        // If you have a Slot object, you can find out its slot.id, but you cannot\r\n        // guess the slot.id of a Slot you don't have access to, thanks to the\r\n        // randomized suffix.\r\n        this.id = [\r\n            \"slot\",\r\n            idCounter++,\r\n            Date.now(),\r\n            Math.random().toString(36).slice(2),\r\n        ].join(\":\");\r\n    }\r\n    Slot.prototype.hasValue = function () {\r\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\r\n            // We use the Slot object iself as a key to its value, which means the\r\n            // value cannot be obtained without a reference to the Slot object.\r\n            if (this.id in context_1.slots) {\r\n                var value = context_1.slots[this.id];\r\n                if (value === MISSING_VALUE)\r\n                    break;\r\n                if (context_1 !== currentContext) {\r\n                    // Cache the value in currentContext.slots so the next lookup will\r\n                    // be faster. This caching is safe because the tree of contexts and\r\n                    // the values of the slots are logically immutable.\r\n                    currentContext.slots[this.id] = value;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        if (currentContext) {\r\n            // If a value was not found for this Slot, it's never going to be found\r\n            // no matter how many times we look it up, so we might as well cache\r\n            // the absence of the value, too.\r\n            currentContext.slots[this.id] = MISSING_VALUE;\r\n        }\r\n        return false;\r\n    };\r\n    Slot.prototype.getValue = function () {\r\n        if (this.hasValue()) {\r\n            return currentContext.slots[this.id];\r\n        }\r\n    };\r\n    Slot.prototype.withValue = function (value, callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        var _a;\r\n        var slots = (_a = {\r\n                __proto__: null\r\n            },\r\n            _a[this.id] = value,\r\n            _a);\r\n        var parent = currentContext;\r\n        currentContext = { parent: parent, slots: slots };\r\n        try {\r\n            // Function.prototype.apply allows the arguments array argument to be\r\n            // omitted or undefined, so args! is fine here.\r\n            return callback.apply(thisArg, args);\r\n        }\r\n        finally {\r\n            currentContext = parent;\r\n        }\r\n    };\r\n    // Capture the current context and wrap a callback function so that it\r\n    // reestablishes the captured context when called.\r\n    Slot.bind = function (callback) {\r\n        var context = currentContext;\r\n        return function () {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = context;\r\n                return callback.apply(this, arguments);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        };\r\n    };\r\n    // Immediately run a callback function without any captured context.\r\n    Slot.noContext = function (callback, \r\n    // Given the prevalence of arrow functions, specifying arguments is likely\r\n    // to be much more common than specifying `this`, hence this ordering:\r\n    args, thisArg) {\r\n        if (currentContext) {\r\n            var saved = currentContext;\r\n            try {\r\n                currentContext = null;\r\n                // Function.prototype.apply allows the arguments array argument to be\r\n                // omitted or undefined, so args! is fine here.\r\n                return callback.apply(thisArg, args);\r\n            }\r\n            finally {\r\n                currentContext = saved;\r\n            }\r\n        }\r\n        else {\r\n            return callback.apply(thisArg, args);\r\n        }\r\n    };\r\n    return Slot;\r\n}()); };\r\n// We store a single global implementation of the Slot class as a permanent\r\n// non-enumerable symbol property of the Array constructor. This obfuscation\r\n// does nothing to prevent access to the Slot class, but at least it ensures\r\n// the implementation (i.e. currentContext) cannot be tampered with, and all\r\n// copies of the @wry/context package (hopefully just one) will share the\r\n// same Slot implementation. Since the first copy of the @wry/context package\r\n// to be imported wins, this technique imposes a very high cost for any\r\n// future breaking changes to the Slot class.\r\nvar globalKey = \"@wry/context:Slot\";\r\nvar host = Array;\r\nvar Slot = host[globalKey] || function () {\r\n    var Slot = makeSlotClass();\r\n    try {\r\n        Object.defineProperty(host, globalKey, {\r\n            value: host[globalKey] = Slot,\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: false,\r\n        });\r\n    }\r\n    finally {\r\n        return Slot;\r\n    }\r\n}();\n\nvar bind = Slot.bind, noContext = Slot.noContext;\r\nfunction setTimeoutWithContext(callback, delay) {\r\n    return setTimeout(bind(callback), delay);\r\n}\r\n// Turn any generator function into an async function (using yield instead\r\n// of await), with context automatically preserved across yields.\r\nfunction asyncFromGen(genFn) {\r\n    return function () {\r\n        var gen = genFn.apply(this, arguments);\r\n        var boundNext = bind(gen.next);\r\n        var boundThrow = bind(gen.throw);\r\n        return new Promise(function (resolve, reject) {\r\n            function invoke(method, argument) {\r\n                try {\r\n                    var result = method.call(gen, argument);\r\n                }\r\n                catch (error) {\r\n                    return reject(error);\r\n                }\r\n                var next = result.done ? resolve : invokeNext;\r\n                if (isPromiseLike(result.value)) {\r\n                    result.value.then(next, result.done ? reject : invokeThrow);\r\n                }\r\n                else {\r\n                    next(result.value);\r\n                }\r\n            }\r\n            var invokeNext = function (value) { return invoke(boundNext, value); };\r\n            var invokeThrow = function (error) { return invoke(boundThrow, error); };\r\n            invokeNext();\r\n        });\r\n    };\r\n}\r\nfunction isPromiseLike(value) {\r\n    return value && typeof value.then === \"function\";\r\n}\r\n// If you use the fibers npm package to implement coroutines in Node.js,\r\n// you should call this function at least once to ensure context management\r\n// remains coherent across any yields.\r\nvar wrappedFibers = [];\r\nfunction wrapYieldingFiberMethods(Fiber) {\r\n    // There can be only one implementation of Fiber per process, so this array\r\n    // should never grow longer than one element.\r\n    if (wrappedFibers.indexOf(Fiber) < 0) {\r\n        var wrap = function (obj, method) {\r\n            var fn = obj[method];\r\n            obj[method] = function () {\r\n                return noContext(fn, arguments, this);\r\n            };\r\n        };\r\n        // These methods can yield, according to\r\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\r\n        wrap(Fiber, \"yield\");\r\n        wrap(Fiber.prototype, \"run\");\r\n        wrap(Fiber.prototype, \"throwInto\");\r\n        wrappedFibers.push(Fiber);\r\n    }\r\n    return Fiber;\r\n}\n\nexport { Slot, asyncFromGen, bind, noContext, setTimeoutWithContext as setTimeout, wrapYieldingFiberMethods };\n//# sourceMappingURL=context.esm.js.map\n"],"names":[],"mappings":"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"}