{"version":3,"sources":["../../src/websocket/eventsSocketServer.ts"],"names":["PROTOCOL_VERSION","parseMessage","data","message","JSON","parse","version","logger","error","undefined","serializeMessage","toSerialize","Error","escapeString","highlight","maxDepth","min","type","map","item","plugins","prettyFormat","ReactElement","stringify","e","attachToServer","server","path","messageSocket","wss","WebSocketServer","verifyClient","origin","startsWith","clients","Map","nextClientId","broadCastEvent","size","serialized","ws","values","send","toString","on","clientWs","clientId","set","onclose","onerror","delete","onmessage","event","broadcast","command","params","reportEvent"],"mappings":"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","sourcesContent":["import {Server as WebSocketServer} from 'ws';\nimport {logger} from '@react-native-community/cli-tools';\nimport prettyFormat from 'pretty-format';\nimport {Server as HttpServer} from 'http';\nimport {Server as HttpsServer} from 'https';\nimport messageSocketModule from './messageSocketServer';\n\n/**\n * The eventsSocket websocket listens at the 'events/` for websocket\n * connections, on which all Metro reports will be emitted.\n *\n * This is mostly useful for developer tools (clients) that wants to monitor Metro,\n * and the apps connected to Metro.\n *\n * The eventsSocket provides the following features:\n * - it reports any Metro event (that is reported through a reporter) to all clients\n * - it reports any console.log's (and friends) from the connected app to all clients\n *   (as client_log event)\n * - it allows connected clients to send commands through Metro to the connected app.\n *   This reuses the generic command mechanism.\n *   Two useful commands are 'reload' and 'devmenu'.\n */\n\ntype Server = HttpServer | HttpsServer;\n\ntype Command = {\n  version: number;\n  type: 'command';\n  command: string;\n  params?: any;\n};\n\n/**\n * This number is used to version the communication protocol between\n * Dev tooling like Flipper and Metro, so that in the future we can recognize\n * messages coming from old clients, so that it will be simpler to implement\n * backward compatibility.\n *\n * We start at 2 as the protocol is currently the same as used internally at FB,\n * which happens to be at version 2 as well.\n */\nconst PROTOCOL_VERSION = 2;\n\nfunction parseMessage<T extends Object>(data: string): T | undefined {\n  try {\n    const message = JSON.parse(data);\n    if (message.version === PROTOCOL_VERSION) {\n      return message;\n    }\n    logger.error(\n      'Received message had wrong protocol version: ' + message.version,\n    );\n  } catch {\n    logger.error('Failed to parse the message as JSON:\\n' + data);\n  }\n  return undefined;\n}\n\n/**\n * Two types of messages will arrive in this function,\n * 1) messages generated by Metro itself (through the reporter abstraction)\n *    those are yet to be serialized, and can contain any kind of data structure\n * 2) a specific event generated by Metro is `client_log`, which describes\n *    console.* calls in the app.\n *    The arguments send to the console are pretty printed so that they can be\n *    displayed in a nicer way in dev tools\n *\n * @param message\n */\nfunction serializeMessage(message: any) {\n  // We do want to send Metro report messages, but their contents is not guaranteed to be serializable.\n  // For some known types we will pretty print otherwise not serializable parts first:\n  let toSerialize = message;\n  if (message && message.error && message.error instanceof Error) {\n    toSerialize = {\n      ...message,\n      error: prettyFormat(message.error, {\n        escapeString: true,\n        highlight: true,\n        maxDepth: 3,\n        min: true,\n      }),\n    };\n  } else if (message && message.type === 'client_log') {\n    toSerialize = {\n      ...message,\n      data: message.data.map((item: any) =>\n        typeof item === 'string'\n          ? item\n          : prettyFormat(item, {\n              escapeString: true,\n              highlight: true,\n              maxDepth: 3,\n              min: true,\n              plugins: [prettyFormat.plugins.ReactElement],\n            }),\n      ),\n    };\n  }\n  try {\n    return JSON.stringify(toSerialize);\n  } catch (e) {\n    logger.error('Failed to serialize: ' + e);\n    return null;\n  }\n}\n\ntype MessageSocket = ReturnType<typeof messageSocketModule.attachToServer>;\n\n/**\n * Starts the eventsSocket at the given path\n *\n * @param server\n * @param path typically: 'events/'\n * @param messageSocket: webSocket to which all connected RN apps are listening\n */\nfunction attachToServer(\n  server: Server,\n  path: string,\n  messageSocket: MessageSocket,\n) {\n  const wss = new WebSocketServer({\n    server: server,\n    path: path,\n    verifyClient({origin}: {origin: string}) {\n      // This exposes the full JS logs and enables issuing commands like reload\n      // so let's make sure only locally running stuff can connect to it\n      return (\n        origin.startsWith('http://localhost:') || origin.startsWith('file:')\n      );\n    },\n  });\n\n  const clients = new Map();\n  let nextClientId = 0;\n\n  /**\n   * broadCastEvent is called by reportEvent (below), which is called by the\n   * default reporter of this server, to make sure that all Metro events are\n   * broadcasted to all connected clients\n   * (that is, all devtools such as Flipper, _not_: connected apps)\n   *\n   * @param message\n   */\n  function broadCastEvent(message: any) {\n    if (!clients.size) {\n      return;\n    }\n    const serialized = serializeMessage(message);\n    if (!serialized) {\n      return;\n    }\n    for (const ws of clients.values()) {\n      try {\n        ws.send(serialized);\n      } catch (e) {\n        logger.error(\n          `Failed to send broadcast to client due to:\\n ${e.toString()}`,\n        );\n      }\n    }\n  }\n\n  wss.on('connection', function (clientWs) {\n    const clientId = `client#${nextClientId++}`;\n\n    clients.set(clientId, clientWs);\n\n    clientWs.onclose = clientWs.onerror = () => {\n      clients.delete(clientId);\n    };\n\n    clientWs.onmessage = (event) => {\n      const message: Command | undefined = parseMessage(event.data.toString());\n      if (message == null) {\n        return;\n      }\n      if (message.type === 'command') {\n        try {\n          /**\n           * messageSocket.broadcast (not to be confused with our own broadcast above)\n           * forwards a command to all connected React Native applications.\n           */\n          messageSocket.broadcast(message.command, message.params);\n        } catch (e) {\n          logger.error('Failed to forward message to clients: ', e);\n        }\n      } else {\n        logger.error('Unknown message type: ', message.type);\n      }\n    };\n  });\n\n  return {\n    reportEvent: (event: any) => {\n      broadCastEvent(event);\n    },\n  };\n}\n\nexport default {\n  attachToServer,\n};\n"]}