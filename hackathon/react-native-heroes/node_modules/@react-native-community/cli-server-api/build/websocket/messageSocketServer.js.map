{"version":3,"sources":["../../src/websocket/messageSocketServer.ts"],"names":["PROTOCOL_VERSION","parseMessage","data","binary","logger","error","undefined","message","JSON","parse","version","e","isBroadcast","method","id","target","isRequest","isResponse","requestId","clientId","result","attachToServer","server","path","wss","WebSocketServer","clients","Map","nextClientId","getClientWs","clientWs","get","Error","handleSendBroadcast","broadcasterId","forwarded","params","size","warn","otherId","otherWs","send","stringify","toString","on","handleCaughtError","errorMessage","handleServerRequest","forEach","url","upgradeReq","query","forwardRequest","forwardResponse","set","onCloseHandler","onmessage","delete","onclose","onerror","event","broadcast"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport url from 'url';\nimport {Server as WebSocketServer} from 'ws';\nimport {logger} from '@react-native-community/cli-tools';\nimport {Server as HttpServer} from 'http';\nimport {Server as HttpsServer} from 'https';\n\nconst PROTOCOL_VERSION = 2;\n\ntype IdObject = {\n  requestId: string;\n  clientId: string;\n};\n\ntype Message = {\n  version?: string;\n  id?: IdObject;\n  method?: string;\n  target: string;\n  result?: any;\n  error?: Error;\n  params?: Record<string, any>;\n};\n\nfunction parseMessage(data: string, binary: any) {\n  if (binary) {\n    logger.error('Expected text message, got binary!');\n    return undefined;\n  }\n  try {\n    const message = JSON.parse(data);\n    if (message.version === PROTOCOL_VERSION) {\n      return message;\n    }\n    logger.error(\n      `Received message had wrong protocol version: ${message.version}`,\n    );\n  } catch (e) {\n    logger.error(`Failed to parse the message as JSON:\\n${data}`);\n  }\n  return undefined;\n}\n\nfunction isBroadcast(message: Message) {\n  return (\n    typeof message.method === 'string' &&\n    message.id === undefined &&\n    message.target === undefined\n  );\n}\n\nfunction isRequest(message: Message) {\n  return (\n    typeof message.method === 'string' && typeof message.target === 'string'\n  );\n}\n\nfunction isResponse(message: Message) {\n  return (\n    typeof message.id === 'object' &&\n    typeof message.id.requestId !== 'undefined' &&\n    typeof message.id.clientId === 'string' &&\n    (message.result !== undefined || message.error !== undefined)\n  );\n}\n\ntype Server = HttpServer | HttpsServer;\nfunction attachToServer(server: Server, path: string) {\n  const wss = new WebSocketServer({\n    server,\n    path,\n  });\n  const clients = new Map();\n  let nextClientId = 0;\n\n  function getClientWs(clientId: string) {\n    const clientWs = clients.get(clientId);\n    if (clientWs === undefined) {\n      throw new Error(\n        `could not find id \"${clientId}\" while forwarding request`,\n      );\n    }\n    return clientWs;\n  }\n\n  function handleSendBroadcast(\n    broadcasterId: string | null,\n    message: Partial<Message>,\n  ) {\n    const forwarded = {\n      version: PROTOCOL_VERSION,\n      method: message.method,\n      params: message.params,\n    };\n    if (clients.size === 0) {\n      logger.warn(\n        `No apps connected. Sending \"${message.method}\" to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB.`,\n      );\n    }\n    for (const [otherId, otherWs] of clients) {\n      if (otherId !== broadcasterId) {\n        try {\n          otherWs.send(JSON.stringify(forwarded));\n        } catch (e) {\n          logger.error(\n            `Failed to send broadcast to client: '${otherId}' ` +\n              `due to:\\n ${e.toString()}`,\n          );\n        }\n      }\n    }\n  }\n\n  wss.on('connection', (clientWs) => {\n    const clientId = `client#${nextClientId++}`;\n\n    function handleCaughtError(message: Message, error: Error) {\n      const errorMessage = {\n        id: message.id,\n        method: message.method,\n        target: message.target,\n        error: message.error === undefined ? 'undefined' : 'defined',\n        params: message.params === undefined ? 'undefined' : 'defined',\n        result: message.result === undefined ? 'undefined' : 'defined',\n      };\n\n      if (message.id === undefined) {\n        logger.error(\n          `Handling message from ${clientId} failed with:\\n${error}\\n` +\n            `message:\\n${JSON.stringify(errorMessage)}`,\n        );\n      } else {\n        try {\n          clientWs.send(\n            JSON.stringify({\n              version: PROTOCOL_VERSION,\n              error,\n              id: message.id,\n            }),\n          );\n        } catch (e) {\n          logger.error(\n            `Failed to reply to ${clientId} with error:\\n${error}` +\n              `\\nmessage:\\n${JSON.stringify(errorMessage)}` +\n              `\\ndue to error: ${e.toString()}`,\n          );\n        }\n      }\n    }\n\n    function handleServerRequest(message: Message) {\n      let result = null;\n      switch (message.method) {\n        case 'getid':\n          result = clientId;\n          break;\n        case 'getpeers':\n          result = {};\n          clients.forEach((otherWs, otherId) => {\n            if (clientId !== otherId) {\n              result[otherId] = url.parse(otherWs.upgradeReq.url, true).query;\n            }\n          });\n          break;\n        default:\n          throw new Error(`unknown method: ${message.method}`);\n      }\n\n      clientWs.send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          result,\n          id: message.id,\n        }),\n      );\n    }\n\n    function forwardRequest(message: Message) {\n      getClientWs(message.target).send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          method: message.method,\n          params: message.params,\n          id:\n            message.id === undefined\n              ? undefined\n              : {requestId: message.id, clientId},\n        }),\n      );\n    }\n\n    function forwardResponse(message: Message) {\n      if (!message.id) {\n        return;\n      }\n      getClientWs(message.id.clientId).send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          result: message.result,\n          error: message.error,\n          id: message.id.requestId,\n        }),\n      );\n    }\n\n    clients.set(clientId, clientWs);\n    const onCloseHandler = () => {\n      // @ts-ignore\n      clientWs.onmessage = null;\n      clients.delete(clientId);\n    };\n    clientWs.onclose = onCloseHandler;\n    clientWs.onerror = onCloseHandler;\n    clientWs.onmessage = (event: any) => {\n      const message = parseMessage(event.data, event.binary);\n      if (message === undefined) {\n        logger.error('Received message not matching protocol');\n        return;\n      }\n\n      try {\n        if (isBroadcast(message)) {\n          handleSendBroadcast(clientId, message);\n        } else if (isRequest(message)) {\n          if (message.target === 'server') {\n            handleServerRequest(message);\n          } else {\n            forwardRequest(message);\n          }\n        } else if (isResponse(message)) {\n          forwardResponse(message);\n        } else {\n          throw new Error('Invalid message, did not match the protocol');\n        }\n      } catch (e) {\n        handleCaughtError(message, e.toString());\n      }\n    };\n  });\n\n  return {\n    broadcast: (method: string, params?: Record<string, any>) => {\n      handleSendBroadcast(null, {method, params});\n    },\n  };\n}\n\nexport default {attachToServer, parseMessage};\n"]}