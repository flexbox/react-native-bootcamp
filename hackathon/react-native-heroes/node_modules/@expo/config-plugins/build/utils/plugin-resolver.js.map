{"version":3,"sources":["../../src/utils/plugin-resolver.ts"],"names":["pluginFileName","findUpPackageJson","root","packageJson","findUp","sync","cwd","resolvePluginForModule","projectRoot","modulePath","resolved","resolveFrom","silent","PluginError","moduleNameIsDirectFileReference","isPluginFile","filePath","findUpPlugin","pathIsFilePath","name","match","slashCount","split","path","sep","length","startsWith","resolveExpoPluginFile","pluginModuleFile","moduleRoot","dirname","pluginFile","normalizeStaticPlugin","plugin","Array","isArray","undefined","assertInternalProjectRoot","resolveConfigPluginFunction","pluginReference","resolveConfigPluginFunctionWithInfo","result","requirePluginFile","error","SyntaxError","learnMoreLink","pluginError","message","stack","resolveConfigPluginExport","default","require"],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport findUp from 'find-up';\nimport * as path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { PluginError } from './errors';\nimport { fileExists } from './modules';\n\n// Default plugin entry file name.\nexport const pluginFileName = 'app.plugin.js';\n\nfunction findUpPackageJson(root: string): string {\n  const packageJson = findUp.sync('package.json', { cwd: root });\n  assert(packageJson, `No package.json found for module \"${root}\"`);\n  return packageJson;\n}\n\nexport function resolvePluginForModule(projectRoot: string, modulePath: string) {\n  const resolved = resolveFrom.silent(projectRoot, modulePath);\n  if (!resolved) {\n    throw new PluginError(\n      `Failed to resolve plugin for module \"${modulePath}\" relative to \"${projectRoot}\"`,\n      'PLUGIN_NOT_FOUND'\n    );\n  }\n  // If the modulePath is something like `@bacon/package/index.js` or `expo-foo/build/app`\n  // then skip resolving the module `app.plugin.js`\n  if (moduleNameIsDirectFileReference(modulePath)) {\n    return { isPluginFile: false, filePath: resolved };\n  }\n  return findUpPlugin(resolved);\n}\n\n// TODO: Test windows\nfunction pathIsFilePath(name: string): boolean {\n  // Matches lines starting with: . / ~/\n  return !!name.match(/^(\\.|~\\/|\\/)/g);\n}\n\nexport function moduleNameIsDirectFileReference(name: string): boolean {\n  if (pathIsFilePath(name)) {\n    return true;\n  }\n\n  const slashCount = name.split(path.sep)?.length;\n  // Orgs (like @expo/config ) should have more than one slash to be a direct file.\n  if (name.startsWith('@')) {\n    return slashCount > 2;\n  }\n\n  // Regular packages should be considered direct reference if they have more than one slash.\n  return slashCount > 1;\n}\n\nfunction resolveExpoPluginFile(root: string): string | null {\n  // Find the expo plugin root file\n  const pluginModuleFile = resolveFrom.silent(\n    root,\n    // use ./ so it isn't resolved as a node module\n    `./${pluginFileName}`\n  );\n\n  // If the default expo plugin file exists use it.\n  if (pluginModuleFile && fileExists(pluginModuleFile)) {\n    return pluginModuleFile;\n  }\n  return null;\n}\n\nfunction findUpPlugin(root: string): { filePath: string; isPluginFile: boolean } {\n  // Get the closest package.json to the node module\n  const packageJson = findUpPackageJson(root);\n  // resolve the root folder for the node module\n  const moduleRoot = path.dirname(packageJson);\n  // use whatever the initial resolved file was ex: `node_modules/my-package/index.js` or `./something.js`\n  const pluginFile = resolveExpoPluginFile(moduleRoot);\n  return { filePath: pluginFile ?? root, isPluginFile: !!pluginFile };\n}\n\nexport function normalizeStaticPlugin(plugin: StaticPlugin | ConfigPlugin | string): StaticPlugin {\n  if (Array.isArray(plugin)) {\n    assert(\n      plugin.length > 0 && plugin.length < 3,\n      `Wrong number of arguments provided for static config plugin, expected either 1 or 2, got ${plugin.length}`\n    );\n    return plugin;\n  }\n  return [plugin, undefined];\n}\n\nexport function assertInternalProjectRoot(projectRoot?: string): asserts projectRoot {\n  assert(\n    projectRoot,\n    `Unexpected: Config \\`_internal.projectRoot\\` isn't defined by expo-cli, this is a bug.`\n  );\n}\n\n// Resolve the module function and assert type\nexport function resolveConfigPluginFunction(projectRoot: string, pluginReference: string) {\n  const { plugin } = resolveConfigPluginFunctionWithInfo(projectRoot, pluginReference);\n  return plugin;\n}\n\n// Resolve the module function and assert type\nexport function resolveConfigPluginFunctionWithInfo(projectRoot: string, pluginReference: string) {\n  const { filePath: pluginFile, isPluginFile } = resolvePluginForModule(\n    projectRoot,\n    pluginReference\n  );\n  let result: any;\n  try {\n    result = requirePluginFile(pluginFile);\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      const learnMoreLink = `Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin`;\n      // If the plugin reference is a node module, and that node module has a syntax error, then it probably doesn't have an official config plugin.\n      if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {\n        const pluginError = new PluginError(\n          `Package \"${pluginReference}\" does not contain a valid config plugin.\\n${learnMoreLink}\\n\\n${error.message}`,\n          'INVALID_PLUGIN_IMPORT'\n        );\n        pluginError.stack = error.stack;\n        throw pluginError;\n      }\n    }\n    throw error;\n  }\n\n  const plugin = resolveConfigPluginExport({\n    plugin: result,\n    pluginFile,\n    pluginReference,\n    isPluginFile,\n  });\n  return { plugin, pluginFile, pluginReference, isPluginFile };\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param props.plugin plugin results\n * @param props.pluginFile plugin file path\n * @param props.pluginReference the string used to reference the plugin\n * @param props.isPluginFile is file path from the app.plugin.js module root\n */\nexport function resolveConfigPluginExport({\n  plugin,\n  pluginFile,\n  pluginReference,\n  isPluginFile,\n}: {\n  plugin: any;\n  pluginFile: string;\n  pluginReference: string;\n  isPluginFile: boolean;\n}): ConfigPlugin<unknown> {\n  if (plugin.default != null) {\n    plugin = plugin.default;\n  }\n  if (typeof plugin !== 'function') {\n    const learnMoreLink = `Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin`;\n    // If the plugin reference is a node module, and that node module does not export a function then it probably doesn't have a config plugin.\n    if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {\n      throw new PluginError(\n        `Package \"${pluginReference}\" does not contain a valid config plugin. Module must export a function from file: ${pluginFile}\\n${learnMoreLink}`,\n        'INVALID_PLUGIN_TYPE'\n      );\n    }\n    throw new PluginError(\n      `Plugin \"${pluginReference}\" must export a function from file: ${pluginFile}. ${learnMoreLink}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  return plugin;\n}\n\nfunction requirePluginFile(filePath: string): any {\n  try {\n    return require(filePath);\n  } catch (error) {\n    // TODO: Improve error messages\n    throw error;\n  }\n}\n"],"file":"plugin-resolver.js"}