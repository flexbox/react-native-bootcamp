{"version":3,"sources":["../../src/ios/codeMod.ts"],"names":["addObjcImports","source","imports","lines","split","lineIndexWithFirstImport","findIndex","line","match","importElement","includes","importStatement","splice","join","findObjcInterfaceCodeBlock","contents","declaration","start","search","RegExp","end","indexOf","code","substring","findObjcFunctionCodeBlock","selector","symbols","argsCount","length","pattern","i","argSymbol","insertContentsInsideObjcFunctionBlock","srcContents","insertion","options","insertContentsInsideFunctionBlock","insertContentsInsideObjcInterfaceBlock","codeBlock","position","firstNewLineIndex","endLen","findSwiftFunctionCodeBlock","parenthesesIndex","funcName","argLabels","searchOffset","funcCandidateRegExp","funcCandidateOffset","paramsStartOffset","paramsEndOffset","paramsString","params","map","parseSwiftFunctionParam","argumentLabel","codeBlockStart","codeBlockEnd","paramTuple","semiIndex","parameterName","typeString","trim","insertContentsInsideSwiftClassBlock","Error","firstBracketIndex","endBracketIndex","insertContentsInsideSwiftFunctionBlock","language","indent","repeat","lastReturnIndex","lastIndexOf"],"mappings":"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","sourcesContent":["import { CodeBlock, insertContentsAtOffset, searchFromOffset } from '../utils/commonCodeMod';\nimport { findMatchingBracketPosition } from '../utils/matchBrackets';\n\ninterface SwiftFunctionParam {\n  argumentLabel: string;\n  parameterName: string;\n  typeString: string;\n}\n\ninterface InsertContentFunctionOptions {\n  position: 'head' | 'tail' | 'tailBeforeLastReturn';\n  indent?: number;\n}\n\n/**\n * Add Objective-C import\n * @param source source contents\n * @param imports array of imports, e.g. ['<Foundation/Foundation.h>']\n * @returns updated contents\n */\nexport function addObjcImports(source: string, imports: string[]): string {\n  const lines = source.split('\\n');\n  // Try to insert statements after first #import where would probably not in #if block\n  const lineIndexWithFirstImport = lines.findIndex(line => line.match(/^#import .*$/));\n  for (const importElement of imports) {\n    if (!source.includes(importElement)) {\n      const importStatement = `#import ${importElement}`;\n      lines.splice(lineIndexWithFirstImport + 1, 0, importStatement);\n    }\n  }\n  return lines.join('\\n');\n}\n\n/**\n * Find code block of Objective-C interface or implementation\n *\n * @param contents source contents\n * @param declaration interface/implementation, e.g. '@interface Foo'\n * @returns found CodeBlock, or null if not found\n */\nexport function findObjcInterfaceCodeBlock(\n  contents: string,\n  declaration: string\n): CodeBlock | null {\n  const start = contents.search(new RegExp(`^${declaration}\\\\W`, 'm'));\n  if (start < 0) {\n    return null;\n  }\n\n  let end = contents.indexOf('\\n@end', start);\n  end += 5; // '\\n@end'.length === 5\n\n  return {\n    start,\n    end,\n    code: contents.substring(start, end),\n  };\n}\n\n/**\n * Find code block of Objective-C function without declaration, will return only {} block\n *\n * @param contents source contents\n * @param selector function selector, e.g. 'doSomething:withSomeValue:'\n * @returns found CodeBlock, or null if not found.\n */\nexport function findObjcFunctionCodeBlock(contents: string, selector: string): CodeBlock | null {\n  const symbols = selector.split(':');\n  const argsCount = symbols.length - 1;\n  let pattern = '^[\\\\-+]\\\\s*\\\\(.+?\\\\)';\n  if (argsCount === 0) {\n    pattern += `${symbols[0]}\\\\s+`;\n  } else {\n    for (let i = 0; i < argsCount; ++i) {\n      const argSymbol = `${symbols[i]}:\\\\(.+\\\\)\\\\w+`;\n      pattern += `${argSymbol}\\\\s+`;\n    }\n  }\n  pattern += '{';\n  let start = contents.search(new RegExp(pattern, 'm'));\n  if (start < 0) {\n    return null;\n  }\n  start = contents.indexOf('{', start);\n\n  const end = findMatchingBracketPosition(contents, '{', start);\n  return {\n    start,\n    end,\n    code: contents.substring(start, end + 1),\n  };\n}\n\n/**\n * Insert contents to the Objective-C function block\n *\n * @param srcContents source contents\n * @param selector function selector, e.g. 'doSomething:withSomeValue:'\n * @param insertion code to insert\n * @param options insertion options\n * @returns updated contents\n */\nexport function insertContentsInsideObjcFunctionBlock(\n  srcContents: string,\n  selector: string,\n  insertion: string,\n  options: InsertContentFunctionOptions\n): string {\n  return insertContentsInsideFunctionBlock(srcContents, selector, insertion, options, 'objc');\n}\n\n/**\n * Insert contents to the Objective-C interface/implementation block\n *\n * @param srcContents source contents\n * @param declaration interface/implementation, e.g. '@interface Foo'\n * @param insertion code to insert\n * @param options insertion options\n * @returns updated contents\n */\nexport function insertContentsInsideObjcInterfaceBlock(\n  srcContents: string,\n  declaration: string,\n  insertion: string,\n  options: {\n    position: 'head' | 'tail';\n  }\n): string {\n  const codeBlock = findObjcInterfaceCodeBlock(srcContents, declaration);\n  if (!codeBlock) {\n    return srcContents;\n  }\n\n  const { position } = options;\n  if (position === 'head') {\n    const firstNewLineIndex = srcContents.indexOf('\\n', codeBlock.start);\n    srcContents = insertContentsAtOffset(srcContents, insertion, firstNewLineIndex);\n  } else if (position === 'tail') {\n    const endLen = '@end'.length;\n    srcContents = insertContentsAtOffset(srcContents, insertion, codeBlock.end - endLen);\n  }\n  return srcContents;\n}\n\n/**\n * Find code block of Swift function without declaration, will return only {} block\n *\n * @param contents source contents\n * @param selector function selector, e.g. 'doSomething(_:withSomeValue:)'\n * @returns found CodeBlock, or null if not found.\n */\nexport function findSwiftFunctionCodeBlock(contents: string, selector: string): CodeBlock | null {\n  const parenthesesIndex = selector.indexOf('(');\n  // `functName` === 'doSomething' of 'doSomething(_:withSomeValue:)'\n  const funcName = selector.substring(0, parenthesesIndex);\n  // `argLabels` === ['_', 'withSomeValue'] 'doSomething(_:withSomeValue:)'\n  const argLabels = selector.substring(parenthesesIndex + 1, selector.length - 2).split(':');\n\n  let searchOffset = 0;\n  const funcCandidateRegExp = new RegExp(`\\\\sfunc\\\\s+${funcName}\\\\(`, 'm');\n  let funcCandidateOffset = searchFromOffset(contents, funcCandidateRegExp, searchOffset);\n  while (funcCandidateOffset >= 0) {\n    // Parse function parameters\n    const paramsStartOffset = contents.indexOf('(', funcCandidateOffset);\n    const paramsEndOffset = findMatchingBracketPosition(contents, '(', paramsStartOffset);\n    const paramsString = contents.substring(paramsStartOffset + 1, paramsEndOffset);\n    const params = paramsString.split(',').map(parseSwiftFunctionParam);\n\n    // Prepare offset for next round\n    searchOffset = paramsEndOffset + 1;\n    funcCandidateOffset = searchFromOffset(contents, funcCandidateRegExp, searchOffset);\n\n    // Try to match function parameters\n    if (argLabels.length !== params.length) {\n      continue;\n    }\n    for (let i = 0; i < argLabels.length; ++i) {\n      if (argLabels[i] !== params[i].argumentLabel) {\n        continue;\n      }\n    }\n\n    // This function is matched one, get the code block.\n    const codeBlockStart = contents.indexOf('{', paramsEndOffset);\n    const codeBlockEnd = findMatchingBracketPosition(contents, '{', paramsEndOffset);\n    const codeBlock = contents.substring(codeBlockStart, codeBlockEnd + 1);\n    return {\n      start: codeBlockStart,\n      end: codeBlockEnd,\n      code: codeBlock,\n    };\n  }\n\n  return null;\n}\n\nfunction parseSwiftFunctionParam(paramTuple: string): SwiftFunctionParam {\n  const semiIndex = paramTuple.indexOf(':');\n  const [argumentLabel, parameterName] = paramTuple.substring(0, semiIndex).split(/\\s+/);\n  const typeString = paramTuple.substring(semiIndex + 1).trim();\n  return {\n    argumentLabel,\n    parameterName,\n    typeString,\n  };\n}\n\n/**\n * Insert contents to the swift class block\n *\n * @param srcContents source contents\n * @param declaration class/extension declaration, e.g. 'class AppDelegate'\n * @param insertion code to append\n * @param options insertion options\n * @returns updated contents\n */\nexport function insertContentsInsideSwiftClassBlock(\n  srcContents: string,\n  declaration: string,\n  insertion: string,\n  options: {\n    position: 'head' | 'tail';\n  }\n): string {\n  const start = srcContents.search(new RegExp(`\\\\s*${declaration}.*?[\\\\(\\\\{]`));\n  if (start < 0) {\n    throw new Error(`Unable to find class code block - declaration[${declaration}]`);\n  }\n\n  const { position } = options;\n  if (position === 'head') {\n    const firstBracketIndex = srcContents.indexOf('{', start);\n    srcContents = insertContentsAtOffset(srcContents, insertion, firstBracketIndex + 1);\n  } else if (position === 'tail') {\n    const endBracketIndex = findMatchingBracketPosition(srcContents, '{', start);\n    srcContents = insertContentsAtOffset(srcContents, insertion, endBracketIndex);\n  }\n  return srcContents;\n}\n\n/**\n * Insert contents to the Swift function block\n *\n * @param srcContents source contents\n * @param selector function selector, e.g. 'doSomething:withSomeValue:'\n * @param insertion code to insert\n * @param options insertion options\n * @returns updated contents\n */\nexport function insertContentsInsideSwiftFunctionBlock(\n  srcContents: string,\n  selector: string,\n  insertion: string,\n  options: InsertContentFunctionOptions\n): string {\n  return insertContentsInsideFunctionBlock(srcContents, selector, insertion, options, 'swift');\n}\n\nfunction insertContentsInsideFunctionBlock(\n  srcContents: string,\n  selector: string,\n  insertion: string,\n  options: InsertContentFunctionOptions,\n  language: 'objc' | 'swift'\n): string {\n  const codeBlock =\n    language === 'objc'\n      ? findObjcFunctionCodeBlock(srcContents, selector)\n      : findSwiftFunctionCodeBlock(srcContents, selector);\n  if (!codeBlock) {\n    return srcContents;\n  }\n\n  const { position } = options;\n  const indent = ' '.repeat(options.indent ?? 2);\n\n  if (position === 'head') {\n    srcContents = insertContentsAtOffset(\n      srcContents,\n      `\\n${indent}${insertion}`,\n      codeBlock.start + 1\n    );\n  } else if (position === 'tail') {\n    srcContents = insertContentsAtOffset(srcContents, `\\n${indent}${insertion}`, codeBlock.end - 1);\n  } else if (position === 'tailBeforeLastReturn') {\n    let lastReturnIndex = srcContents.lastIndexOf(' return ', codeBlock.end);\n    if (lastReturnIndex < 0) {\n      throw new Error(`Cannot find last return statement:\\n${srcContents}`);\n    }\n    lastReturnIndex += 1; // +1 for the prefix space\n    srcContents = insertContentsAtOffset(srcContents, `${insertion}\\n${indent}`, lastReturnIndex);\n  }\n\n  return srcContents;\n}\n"],"file":"codeMod.js"}