{"version":3,"sources":["../../src/utils/XML.ts"],"names":["writeXMLAsync","options","xml","Builder","buildObject","fs","ensureDir","path","dirname","writeFile","readXMLAsync","contents","readFile","encoding","flag","parser","Parser","manifest","parseStringPromise","fallback","parseXMLAsync","stringTimesN","n","char","Array","join","format","indentLevel","newline","EOL","xmlInput","toString","builder","headless","Error","indentString","formatted","regex","replace","pad","split","map","line","trim","forEach","indent","match","padding"],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport { EOL } from 'os';\nimport path from 'path';\nimport { Builder, Parser } from 'xml2js';\n\nexport type XMLValue = boolean | number | string | null | XMLArray | XMLObject;\n\nexport interface XMLArray extends Array<XMLValue> {}\n\nexport interface XMLObject {\n  [key: string]: XMLValue | undefined;\n}\n\nexport async function writeXMLAsync(options: { path: string; xml: any }): Promise<void> {\n  const xml = new Builder().buildObject(options.xml);\n  await fs.ensureDir(path.dirname(options.path));\n  await fs.writeFile(options.path, xml);\n}\n\nexport async function readXMLAsync(options: {\n  path: string;\n  fallback?: string | null;\n}): Promise<XMLObject> {\n  let contents: string = '';\n  try {\n    contents = await fs.readFile(options.path, { encoding: 'utf8', flag: 'r' });\n  } catch {\n    // catch and use fallback\n  }\n  const parser = new Parser();\n  const manifest = await parser.parseStringPromise(contents || options.fallback || '');\n  return manifest;\n}\n\nexport async function parseXMLAsync(contents: string): Promise<XMLObject> {\n  const xml = await new Parser().parseStringPromise(contents);\n  return xml;\n}\n\nconst stringTimesN = (n: number, char: string) => Array(n + 1).join(char);\n\nexport function format(manifest: any, { indentLevel = 2, newline = EOL } = {}): string {\n  let xmlInput: string;\n  if (typeof manifest === 'string') {\n    xmlInput = manifest;\n  } else if (manifest.toString) {\n    const builder = new Builder({ headless: true });\n    xmlInput = builder.buildObject(manifest);\n    return xmlInput;\n  } else {\n    throw new Error(`Invalid XML value passed in: ${manifest}`);\n  }\n  const indentString = stringTimesN(indentLevel, ' ');\n\n  let formatted = '';\n  const regex = /(>)(<)(\\/*)/g;\n  const xml = xmlInput.replace(regex, `$1${newline}$2$3`);\n  let pad = 0;\n  xml\n    .split(/\\r?\\n/)\n    .map((line: string) => line.trim())\n    .forEach((line: string) => {\n      let indent = 0;\n      if (line.match(/.+<\\/\\w[^>]*>$/)) {\n        indent = 0;\n      } else if (line.match(/^<\\/\\w/)) {\n        // Somehow istanbul doesn't see the else case as covered, although it is. Skip it.\n        /* istanbul ignore else  */\n        if (pad !== 0) {\n          pad -= 1;\n        }\n      } else if (line.match(/^<\\w([^>]*[^/])?>.*$/)) {\n        indent = 1;\n      } else {\n        indent = 0;\n      }\n\n      const padding = stringTimesN(pad, indentString);\n      formatted += padding + line + newline; // eslint-disable-line prefer-template\n      pad += indent;\n    });\n\n  return formatted.trim();\n}\n"],"file":"XML.js"}